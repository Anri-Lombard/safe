{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Overview","text":"\ud83e\uddba SAFE  Sequential Attachment-based Fragment Embedding (SAFE) is a novel molecular line notation that represents molecules as an unordered sequence of fragment blocks to improve molecule design using generative models. <p>        Paper    |          Docs    |        \ud83e\udd17 Model    </p> <p></p> <p> </p> <p> </p>"},{"location":"index.html#overview-of-safe","title":"Overview of SAFE","text":"<p>SAFE is the deep learning molecular representation. It's an encoding leveraging a peculiarity in the decoding schemes of SMILES, to allow representation of molecules as contiguous sequence of connected fragment. SAFE strings are valid SMILES string, and thus are able to preserve the same amount of information. The intuitive representation of molecules as unordered sequence of connected fragments gretly simplify the following tasks often encoutered in molecular design:</p> <ul> <li>de novo design</li> <li>superstructure generation</li> <li>scaffold decoration</li> <li>motif extension</li> <li>linker generation</li> <li>scaffold morphing.</li> </ul> <p>The construction of a SAFE strings requires definition a molecular fragmentation algorithm. By default, we use [BRICS], but any other fragmentation algorithm can be used. The image below illustrate the process of building a SAFE string. The resulting string is a valid SMILES that can be read by datamol or RDKit.</p> <p></p>"},{"location":"index.html#installation","title":"Installation","text":"<p>You can install <code>safe</code> using pip:</p> <pre><code>pip install safe-mol\n</code></pre> <p>You can use conda/mamba. Ask @maclandrol for credentials to the conda forge or for a token</p> <pre><code>mamba install -c conda-forge safe-mol\n</code></pre>"},{"location":"index.html#datasets-and-models","title":"Datasets and Models","text":"<p>We provided a pretained GPT2 model (XX M parameters) using the SAFE molecular representation that has been trained on 1.1 billion molecules from Unichem (0.1B) + Zinc (1B):</p> <ul> <li>Safe-XXM TODO</li> </ul>"},{"location":"index.html#usage","title":"Usage","text":"<p>Please refer to the documentation, which contains tutorials for getting started with <code>safe</code> and detailed descriptions of the functions provided.</p>"},{"location":"index.html#api","title":"API","text":"<p>We summarize some key functions provided by the <code>safe</code> package below.</p> Function Description <code>safe.encode</code> Translates a SMILES string into its corresponding SAFE string. <code>safe.decode</code> Translates a SAFE string into its corresponding SMILES string. The SAFE decoder just augment RDKit's <code>Chem.MolFromSmiles</code> with an optional correction argument to take care of missing hydrogens bonds. <code>safe.split</code> Tokenizes a SAFE string to build a generative model."},{"location":"index.html#examples","title":"Examples","text":""},{"location":"index.html#translation-between-safe-and-smiles-representations","title":"Translation between SAFE and SMILES representations","text":"<pre><code>import safe\n\nibuprofen = \"CC(Cc1ccc(cc1)C(C(=O)O)C)C\"\n\n# SMILES -&gt; SAFE -&gt; SMILES translation\ntry:\n    ibuprofen_sf = safe.encode(ibuprofen)  # [C][=C][C][=C][C][=C][Ring1][=Branch1]\n    ibuprofen_smi = safe.decode(ibuprofen_sf, canonical=True)  # CC(Cc1ccc(cc1)C(C(=O)O)C)C\nexcept safe.EncoderError:\n    pass\nexcept safe.DecoderError:\n    pass\n\nibuprofen_tokens = list(safe.split(ibuprofen_sf))\n# ['[C]', '[=C]', '[C]', '[=C]', '[C]', '[=C]', '[Ring1]', '[=Branch1]']\n</code></pre>"},{"location":"index.html#training-a-new-models","title":"Training a new models","text":"<p>A command line interface is available to train a new model, please run <code>safe-train --help</code></p> <p>For example:</p> <pre><code>safe-train --config &lt;path to config&gt; \\\n    --model-path &lt;path to model&gt; \\\n    --tokenizer  &lt;path to tokenizer&gt; \\\n    --dataset &lt;path to dataset&gt; \\\n    --num_labels 9 \\\n    --torch_compile True \\\n    --optim \"adamw_torch\" \\\n    --learning_rate 1e-5 \\\n    --prop_loss_coeff 1e-3 \\\n    --gradient_accumulation_steps 1 \\\n    --output_dir \"&lt;path to outputdir&gt;\" \\\n    --max_steps 5\n</code></pre>"},{"location":"index.html#references","title":"References","text":"<p>If you use this repository, please cite the following related paper:</p> <pre><code>@misc{noutahi2023gotta,\n      title={Gotta be SAFE: A New Framework for Molecular Design},\n      author={Emmanuel Noutahi and Cristian Gabellini and Michael Craig and Jonathan S. C Lim and Prudencio Tossou},\n      year={2023},\n      eprint={2310.10773},\n      archivePrefix={arXiv},\n      primaryClass={cs.LG}\n}\n</code></pre>"},{"location":"index.html#license","title":"License","text":"<p>Note that all data and model weights of SAFE are exclusively licensed for research purposes. The accompanying dataset is licensed under CC BY 4.0, which permits solely non-commercial usage. See DATA_LICENSE for details.</p> <p>This code base is licensed under the Apache-2.0 license. See LICENSE for details.</p>"},{"location":"index.html#development-lifecycle","title":"Development lifecycle","text":""},{"location":"index.html#setup-dev-environment","title":"Setup dev environment","text":"<pre><code>mamba create -n safe -f env.yml\nmamba activate safe\n\npip install --no-deps -e .\n</code></pre>"},{"location":"index.html#tests","title":"Tests","text":"<p>You can run tests locally with:</p> <pre><code>pytest\n</code></pre>"},{"location":"cli.html","title":"CLI for model Training","text":"<p>You can train a new <code>SAFE</code> generative models using the provided CLI, which uses \ud83e\udd17 Transformers !</p> <p>Usage: </p> <pre><code>safe-train [-h] [--model_path MODEL_PATH] [--config CONFIG] [--tokenizer TOKENIZER] [--num_labels NUM_LABELS]\n              [--include_descriptors [INCLUDE_DESCRIPTORS]] [--no_include_descriptors] [--prop_loss_coeff PROP_LOSS_COEFF]\n              [--wandb_project WANDB_PROJECT] [--wandb_watch {gradients,all}] [--cache_dir CACHE_DIR]\n              [--torch_dtype {auto,bfloat16,float16,float32}] [--low_cpu_mem_usage [LOW_CPU_MEM_USAGE]] [--model_max_length MODEL_MAX_LENGTH]\n              [--dataset DATASET] [--is_tokenized [IS_TOKENIZED]] [--streaming [STREAMING]] [--text_column TEXT_COLUMN] --output_dir\n              OUTPUT_DIR [--overwrite_output_dir [OVERWRITE_OUTPUT_DIR]] [--do_train [DO_TRAIN]] [--do_eval [DO_EVAL]]\n              [--do_predict [DO_PREDICT]] [--evaluation_strategy {no,steps,epoch}] [--prediction_loss_only [PREDICTION_LOSS_ONLY]]\n              [--per_device_train_batch_size PER_DEVICE_TRAIN_BATCH_SIZE] [--per_device_eval_batch_size PER_DEVICE_EVAL_BATCH_SIZE]\n              [--per_gpu_train_batch_size PER_GPU_TRAIN_BATCH_SIZE] [--per_gpu_eval_batch_size PER_GPU_EVAL_BATCH_SIZE]\n              [--gradient_accumulation_steps GRADIENT_ACCUMULATION_STEPS] [--eval_accumulation_steps EVAL_ACCUMULATION_STEPS]\n              [--eval_delay EVAL_DELAY] [--learning_rate LEARNING_RATE] [--weight_decay WEIGHT_DECAY] [--adam_beta1 ADAM_BETA1]\n              [--adam_beta2 ADAM_BETA2] [--adam_epsilon ADAM_EPSILON] [--max_grad_norm MAX_GRAD_NORM] [--num_train_epochs NUM_TRAIN_EPOCHS]\n              [--max_steps MAX_STEPS]\n              [--lr_scheduler_type {linear,cosine,cosine_with_restarts,polynomial,constant,constant_with_warmup,inverse_sqrt,reduce_lr_on_plateau}]\n              [--warmup_ratio WARMUP_RATIO] [--warmup_steps WARMUP_STEPS] [--log_level {debug,info,warning,error,critical,passive}]\n              [--log_level_replica {debug,info,warning,error,critical,passive}] [--log_on_each_node [LOG_ON_EACH_NODE]]\n              [--no_log_on_each_node] [--logging_dir LOGGING_DIR] [--logging_strategy {no,steps,epoch}]\n              [--logging_first_step [LOGGING_FIRST_STEP]] [--logging_steps LOGGING_STEPS] [--logging_nan_inf_filter [LOGGING_NAN_INF_FILTER]]\n              [--no_logging_nan_inf_filter] [--save_strategy {no,steps,epoch}] [--save_steps SAVE_STEPS] [--save_total_limit SAVE_TOTAL_LIMIT]\n              [--save_safetensors [SAVE_SAFETENSORS]] [--save_on_each_node [SAVE_ON_EACH_NODE]] [--no_cuda [NO_CUDA]]\n              [--use_mps_device [USE_MPS_DEVICE]] [--seed SEED] [--data_seed DATA_SEED] [--jit_mode_eval [JIT_MODE_EVAL]]\n              [--use_ipex [USE_IPEX]] [--bf16 [BF16]] [--fp16 [FP16]] [--fp16_opt_level FP16_OPT_LEVEL]\n              [--half_precision_backend {auto,cuda_amp,apex,cpu_amp}] [--bf16_full_eval [BF16_FULL_EVAL]] [--fp16_full_eval [FP16_FULL_EVAL]]\n              [--tf32 TF32] [--local_rank LOCAL_RANK] [--ddp_backend {nccl,gloo,mpi,ccl}] [--tpu_num_cores TPU_NUM_CORES]\n              [--tpu_metrics_debug [TPU_METRICS_DEBUG]] [--debug DEBUG [DEBUG ...]] [--dataloader_drop_last [DATALOADER_DROP_LAST]]\n              [--eval_steps EVAL_STEPS] [--dataloader_num_workers DATALOADER_NUM_WORKERS] [--past_index PAST_INDEX] [--run_name RUN_NAME]\n              [--disable_tqdm DISABLE_TQDM] [--remove_unused_columns [REMOVE_UNUSED_COLUMNS]] [--no_remove_unused_columns]\n              [--label_names LABEL_NAMES [LABEL_NAMES ...]] [--load_best_model_at_end [LOAD_BEST_MODEL_AT_END]]\n              [--metric_for_best_model METRIC_FOR_BEST_MODEL] [--greater_is_better GREATER_IS_BETTER] [--ignore_data_skip [IGNORE_DATA_SKIP]]\n              [--sharded_ddp SHARDED_DDP] [--fsdp FSDP] [--fsdp_min_num_params FSDP_MIN_NUM_PARAMS] [--fsdp_config FSDP_CONFIG]\n              [--fsdp_transformer_layer_cls_to_wrap FSDP_TRANSFORMER_LAYER_CLS_TO_WRAP] [--deepspeed DEEPSPEED]\n              [--label_smoothing_factor LABEL_SMOOTHING_FACTOR]\n              [--optim {adamw_hf,adamw_torch,adamw_torch_fused,adamw_torch_xla,adamw_apex_fused,adafactor,adamw_anyprecision,sgd,adagrad,adamw_bnb_8bit,adamw_8bit,lion_8bit,lion_32bit,paged_adamw_32bit,paged_adamw_8bit,paged_lion_32bit,paged_lion_8bit}]\n              [--optim_args OPTIM_ARGS] [--adafactor [ADAFACTOR]] [--group_by_length [GROUP_BY_LENGTH]]\n              [--length_column_name LENGTH_COLUMN_NAME] [--report_to REPORT_TO [REPORT_TO ...]]\n              [--ddp_find_unused_parameters DDP_FIND_UNUSED_PARAMETERS] [--ddp_bucket_cap_mb DDP_BUCKET_CAP_MB]\n              [--ddp_broadcast_buffers DDP_BROADCAST_BUFFERS] [--dataloader_pin_memory [DATALOADER_PIN_MEMORY]] [--no_dataloader_pin_memory]\n              [--skip_memory_metrics [SKIP_MEMORY_METRICS]] [--no_skip_memory_metrics]\n              [--use_legacy_prediction_loop [USE_LEGACY_PREDICTION_LOOP]] [--push_to_hub [PUSH_TO_HUB]]\n              [--resume_from_checkpoint RESUME_FROM_CHECKPOINT] [--hub_model_id HUB_MODEL_ID]\n              [--hub_strategy {end,every_save,checkpoint,all_checkpoints}] [--hub_token HUB_TOKEN] [--hub_private_repo [HUB_PRIVATE_REPO]]\n              [--gradient_checkpointing [GRADIENT_CHECKPOINTING]] [--include_inputs_for_metrics [INCLUDE_INPUTS_FOR_METRICS]]\n              [--fp16_backend {auto,cuda_amp,apex,cpu_amp}] [--push_to_hub_model_id PUSH_TO_HUB_MODEL_ID]\n              [--push_to_hub_organization PUSH_TO_HUB_ORGANIZATION] [--push_to_hub_token PUSH_TO_HUB_TOKEN] [--mp_parameters MP_PARAMETERS]\n              [--auto_find_batch_size [AUTO_FIND_BATCH_SIZE]] [--full_determinism [FULL_DETERMINISM]] [--torchdynamo TORCHDYNAMO]\n              [--ray_scope RAY_SCOPE] [--ddp_timeout DDP_TIMEOUT] [--torch_compile [TORCH_COMPILE]]\n              [--torch_compile_backend TORCH_COMPILE_BACKEND] [--torch_compile_mode TORCH_COMPILE_MODE] [--xpu_backend {mpi,ccl,gloo}]\n</code></pre> <p>Options:</p> <pre><code>-h, --help            show this help message and exit\n--model_path MODEL_PATH\n                        Optional model path or model name to use as a starting point for the safe model (default: None)\n--config CONFIG       Path to the default config file to use for the safe model (default: None)\n--tokenizer TOKENIZER\n--num_labels NUM_LABELS\n                        Optional number of labels for the descriptors (default: None)\n--include_descriptors [INCLUDE_DESCRIPTORS]\n                        Whether to train with descriptors if they are available or Not (default: True)\n--no_include_descriptors\n                        Whether to train with descriptors if they are available or Not (default: False)\n--prop_loss_coeff PROP_LOSS_COEFF\n                        coefficient for the propery loss (default: 0.01)\n--wandb_project WANDB_PROJECT\n                        Name of the wandb project to use to log the SAFE model parameter (default: safe-gpt2)\n--wandb_watch {gradients,all}\n                        Whether to watch the wandb models or not (default: None)\n--cache_dir CACHE_DIR\n                        Where do you want to store the pretrained models downloaded from s3 (default: None)\n--torch_dtype {auto,bfloat16,float16,float32}\n                        Override the default `torch.dtype` and load the model under this dtype. If `auto` is passed, the dtype will be\n                        automatically derived from the model's weights. (default: None)\n--low_cpu_mem_usage [LOW_CPU_MEM_USAGE]\n                        It is an option to create the model as an empty shell, then only materialize its parameters when the pretrained weights\n                        are loaded.set True will benefit LLM loading time and RAM consumption. Only valid when loading a pretrained model\n                        (default: False)\n--model_max_length MODEL_MAX_LENGTH\n                        Maximum sequence length. Sequences will be right padded (and possibly truncated) up to that value. (default: 1024)\n--dataset DATASET     Path to the preprocessed dataset to use for the safe model building (default: None)\n--is_tokenized [IS_TOKENIZED]\n                        whether the dataset submitted as input is already tokenized or not (default: False)\n--streaming [STREAMING]\n                        Whether to use a streaming dataset or not (default: False)\n--text_column TEXT_COLUMN\n                        Column containing text data to process. (default: inputs)\n--output_dir OUTPUT_DIR\n                        The output directory where the model predictions and checkpoints will be written. (default: None)\n--overwrite_output_dir [OVERWRITE_OUTPUT_DIR]\n                        Overwrite the content of the output directory. Use this to continue training if output_dir points to a checkpoint\n                        directory. (default: False)\n--do_train [DO_TRAIN]\n                        Whether to run training. (default: False)\n--do_eval [DO_EVAL]   Whether to run eval on the dev set. (default: False)\n--do_predict [DO_PREDICT]\n                        Whether to run predictions on the test set. (default: False)\n--evaluation_strategy {no,steps,epoch}\n                        The evaluation strategy to use. (default: no)\n--prediction_loss_only [PREDICTION_LOSS_ONLY]\n                        When performing evaluation and predictions, only returns the loss. (default: False)\n--per_device_train_batch_size PER_DEVICE_TRAIN_BATCH_SIZE\n                        Batch size per GPU/TPU core/CPU for training. (default: 8)\n--per_device_eval_batch_size PER_DEVICE_EVAL_BATCH_SIZE\n                        Batch size per GPU/TPU core/CPU for evaluation. (default: 8)\n--per_gpu_train_batch_size PER_GPU_TRAIN_BATCH_SIZE\n                        Deprecated, the use of `--per_device_train_batch_size` is preferred. Batch size per GPU/TPU core/CPU for training.\n                        (default: None)\n--per_gpu_eval_batch_size PER_GPU_EVAL_BATCH_SIZE\n                        Deprecated, the use of `--per_device_eval_batch_size` is preferred. Batch size per GPU/TPU core/CPU for evaluation.\n                        (default: None)\n--gradient_accumulation_steps GRADIENT_ACCUMULATION_STEPS\n                        Number of updates steps to accumulate before performing a backward/update pass. (default: 1)\n--eval_accumulation_steps EVAL_ACCUMULATION_STEPS\n                        Number of predictions steps to accumulate before moving the tensors to the CPU. (default: None)\n--eval_delay EVAL_DELAY\n                        Number of epochs or steps to wait for before the first evaluation can be performed, depending on the evaluation_strategy.\n                        (default: 0)\n--learning_rate LEARNING_RATE\n                        The initial learning rate for AdamW. (default: 5e-05)\n--weight_decay WEIGHT_DECAY\n                        Weight decay for AdamW if we apply some. (default: 0.0)\n--adam_beta1 ADAM_BETA1\n                        Beta1 for AdamW optimizer (default: 0.9)\n--adam_beta2 ADAM_BETA2\n                        Beta2 for AdamW optimizer (default: 0.999)\n--adam_epsilon ADAM_EPSILON\n                        Epsilon for AdamW optimizer. (default: 1e-08)\n--max_grad_norm MAX_GRAD_NORM\n                        Max gradient norm. (default: 1.0)\n--num_train_epochs NUM_TRAIN_EPOCHS\n                        Total number of training epochs to perform. (default: 3.0)\n--max_steps MAX_STEPS\n                        If &gt; 0: set total number of training steps to perform. Override num_train_epochs. (default: -1)\n--lr_scheduler_type {linear,cosine,cosine_with_restarts,polynomial,constant,constant_with_warmup,inverse_sqrt,reduce_lr_on_plateau}\n                        The scheduler type to use. (default: linear)\n--warmup_ratio WARMUP_RATIO\n                        Linear warmup over warmup_ratio fraction of total steps. (default: 0.0)\n--warmup_steps WARMUP_STEPS\n                        Linear warmup over warmup_steps. (default: 0)\n--log_level {debug,info,warning,error,critical,passive}\n                        Logger log level to use on the main node. Possible choices are the log levels as strings: 'debug', 'info', 'warning',\n                        'error' and 'critical', plus a 'passive' level which doesn't set anything and lets the application set the level. Defaults\n                        to 'passive'. (default: passive)\n--log_level_replica {debug,info,warning,error,critical,passive}\n                        Logger log level to use on replica nodes. Same choices and defaults as ``log_level`` (default: warning)\n--log_on_each_node [LOG_ON_EACH_NODE]\n                        When doing a multinode distributed training, whether to log once per node or just once on the main node. (default: True)\n--no_log_on_each_node\n                        When doing a multinode distributed training, whether to log once per node or just once on the main node. (default: False)\n--logging_dir LOGGING_DIR\n                        Tensorboard log dir. (default: None)\n--logging_strategy {no,steps,epoch}\n                        The logging strategy to use. (default: steps)\n--logging_first_step [LOGGING_FIRST_STEP]\n                        Log the first global_step (default: False)\n--logging_steps LOGGING_STEPS\n                        Log every X updates steps. Should be an integer or a float in range `[0,1)`.If smaller than 1, will be interpreted as\n                        ratio of total training steps. (default: 500)\n--logging_nan_inf_filter [LOGGING_NAN_INF_FILTER]\n                        Filter nan and inf losses for logging. (default: True)\n--no_logging_nan_inf_filter\n                        Filter nan and inf losses for logging. (default: False)\n--save_strategy {no,steps,epoch}\n                        The checkpoint save strategy to use. (default: steps)\n--save_steps SAVE_STEPS\n                        Save checkpoint every X updates steps. Should be an integer or a float in range `[0,1)`.If smaller than 1, will be\n                        interpreted as ratio of total training steps. (default: 500)\n--save_total_limit SAVE_TOTAL_LIMIT\n                        If a value is passed, will limit the total amount of checkpoints. Deletes the older checkpoints in `output_dir`. When\n                        `load_best_model_at_end` is enabled, the 'best' checkpoint according to `metric_for_best_model` will always be retained in\n                        addition to the most recent ones. For example, for `save_total_limit=5` and `load_best_model_at_end=True`, the four last\n                        checkpoints will always be retained alongside the best model. When `save_total_limit=1` and `load_best_model_at_end=True`,\n                        it is possible that two checkpoints are saved: the last one and the best one (if they are different). Default is unlimited\n                        checkpoints (default: None)\n--save_safetensors [SAVE_SAFETENSORS]\n                        Use safetensors saving and loading for state dicts instead of default torch.load and torch.save. (default: False)\n--save_on_each_node [SAVE_ON_EACH_NODE]\n                        When doing multi-node distributed training, whether to save models and checkpoints on each node, or only on the main one\n                        (default: False)\n--no_cuda [NO_CUDA]   Do not use CUDA even when it is available (default: False)\n--use_mps_device [USE_MPS_DEVICE]\n                        This argument is deprecated. `mps` device will be used if available similar to `cuda` device. It will be removed in\n                        version 5.0 of \ud83e\udd17 Transformers (default: False)\n--seed SEED           Random seed that will be set at the beginning of training. (default: 42)\n--data_seed DATA_SEED\n                        Random seed to be used with data samplers. (default: None)\n--jit_mode_eval [JIT_MODE_EVAL]\n                        Whether or not to use PyTorch jit trace for inference (default: False)\n--use_ipex [USE_IPEX]\n                        Use Intel extension for PyTorch when it is available, installation: 'https://github.com/intel/intel-extension-for-pytorch'\n                        (default: False)\n--bf16 [BF16]         Whether to use bf16 (mixed) precision instead of 32-bit. Requires Ampere or higher NVIDIA architecture or using CPU\n                        (no_cuda). This is an experimental API and it may change. (default: False)\n--fp16 [FP16]         Whether to use fp16 (mixed) precision instead of 32-bit (default: False)\n--fp16_opt_level FP16_OPT_LEVEL\n                        For fp16: Apex AMP optimization level selected in ['O0', 'O1', 'O2', and 'O3']. See details at\n                        https://nvidia.github.io/apex/amp.html (default: O1)\n--half_precision_backend {auto,cuda_amp,apex,cpu_amp}\n                        The backend to be used for half precision. (default: auto)\n--bf16_full_eval [BF16_FULL_EVAL]\n                        Whether to use full bfloat16 evaluation instead of 32-bit. This is an experimental API and it may change. (default: False)\n--fp16_full_eval [FP16_FULL_EVAL]\n                        Whether to use full float16 evaluation instead of 32-bit (default: False)\n--tf32 TF32           Whether to enable tf32 mode, available in Ampere and newer GPU architectures. This is an experimental API and it may\n                        change. (default: None)\n--local_rank LOCAL_RANK\n                        For distributed training: local_rank (default: -1)\n--ddp_backend {nccl,gloo,mpi,ccl}\n                        The backend to be used for distributed training (default: None)\n--tpu_num_cores TPU_NUM_CORES\n                        TPU: Number of TPU cores (automatically passed by launcher script) (default: None)\n--tpu_metrics_debug [TPU_METRICS_DEBUG]\n                        Deprecated, the use of `--debug tpu_metrics_debug` is preferred. TPU: Whether to print debug metrics (default: False)\n--debug DEBUG [DEBUG ...]\n                        Whether or not to enable debug mode. Current options: `underflow_overflow` (Detect underflow and overflow in activations\n                        and weights), `tpu_metrics_debug` (print debug metrics on TPU). (default: None)\n--dataloader_drop_last [DATALOADER_DROP_LAST]\n                        Drop the last incomplete batch if it is not divisible by the batch size. (default: False)\n--eval_steps EVAL_STEPS\n                        Run an evaluation every X steps. Should be an integer or a float in range `[0,1)`.If smaller than 1, will be interpreted\n                        as ratio of total training steps. (default: None)\n--dataloader_num_workers DATALOADER_NUM_WORKERS\n                        Number of subprocesses to use for data loading (PyTorch only). 0 means that the data will be loaded in the main process.\n                        (default: 0)\n--past_index PAST_INDEX\n                        If &gt;=0, uses the corresponding part of the output as the past state for next step. (default: -1)\n--run_name RUN_NAME   An optional descriptor for the run. Notably used for wandb logging. (default: None)\n--disable_tqdm DISABLE_TQDM\n                        Whether or not to disable the tqdm progress bars. (default: None)\n--remove_unused_columns [REMOVE_UNUSED_COLUMNS]\n                        Remove columns not required by the model when using an nlp.Dataset. (default: True)\n--no_remove_unused_columns\n                        Remove columns not required by the model when using an nlp.Dataset. (default: False)\n--label_names LABEL_NAMES [LABEL_NAMES ...]\n                        The list of keys in your dictionary of inputs that correspond to the labels. (default: None)\n--load_best_model_at_end [LOAD_BEST_MODEL_AT_END]\n                        Whether or not to load the best model found during training at the end of training. When this option is enabled, the best\n                        checkpoint will always be saved. See `save_total_limit` for more. (default: False)\n--metric_for_best_model METRIC_FOR_BEST_MODEL\n                        The metric to use to compare two different models. (default: None)\n--greater_is_better GREATER_IS_BETTER\n                        Whether the `metric_for_best_model` should be maximized or not. (default: None)\n--ignore_data_skip [IGNORE_DATA_SKIP]\n                        When resuming training, whether or not to skip the first epochs and batches to get to the same training data. (default:\n                        False)\n--sharded_ddp SHARDED_DDP\n                        Whether or not to use sharded DDP training (in distributed training only). The base option should be `simple`, `zero_dp_2`\n                        or `zero_dp_3` and you can add CPU-offload to `zero_dp_2` or `zero_dp_3` like this: zero_dp_2 offload` or `zero_dp_3\n                        offload`. You can add auto-wrap to `zero_dp_2` or `zero_dp_3` with the same syntax: zero_dp_2 auto_wrap` or `zero_dp_3\n                        auto_wrap`. (default: )\n--fsdp FSDP           Whether or not to use PyTorch Fully Sharded Data Parallel (FSDP) training (in distributed training only). The base option\n                        should be `full_shard`, `shard_grad_op` or `no_shard` and you can add CPU-offload to `full_shard` or `shard_grad_op` like\n                        this: full_shard offload` or `shard_grad_op offload`. You can add auto-wrap to `full_shard` or `shard_grad_op` with the\n                        same syntax: full_shard auto_wrap` or `shard_grad_op auto_wrap`. (default: )\n--fsdp_min_num_params FSDP_MIN_NUM_PARAMS\n                        This parameter is deprecated. FSDP's minimum number of parameters for Default Auto Wrapping. (useful only when `fsdp`\n                        field is passed). (default: 0)\n--fsdp_config FSDP_CONFIG\n                        Config to be used with FSDP (Pytorch Fully Sharded Data Parallel). The value is either afsdp json config file (e.g.,\n                        `fsdp_config.json`) or an already loaded json file as `dict`. (default: None)\n--fsdp_transformer_layer_cls_to_wrap FSDP_TRANSFORMER_LAYER_CLS_TO_WRAP\n                        This parameter is deprecated. Transformer layer class name (case-sensitive) to wrap, e.g, `BertLayer`, `GPTJBlock`,\n                        `T5Block` .... (useful only when `fsdp` flag is passed). (default: None)\n--deepspeed DEEPSPEED\n                        Enable deepspeed and pass the path to deepspeed json config file (e.g. ds_config.json) or an already loaded json file as a\n                        dict (default: None)\n--label_smoothing_factor LABEL_SMOOTHING_FACTOR\n                        The label smoothing epsilon to apply (zero means no label smoothing). (default: 0.0)\n--optim {adamw_hf,adamw_torch,adamw_torch_fused,adamw_torch_xla,adamw_apex_fused,adafactor,adamw_anyprecision,sgd,adagrad,adamw_bnb_8bit,adamw_8bit,lion_8bit,lion_32bit,paged_adamw_32bit,paged_adamw_8bit,paged_lion_32bit,paged_lion_8bit}\n                        The optimizer to use. (default: adamw_hf)\n--optim_args OPTIM_ARGS\n                        Optional arguments to supply to optimizer. (default: None)\n--adafactor [ADAFACTOR]\n                        Whether or not to replace AdamW by Adafactor. (default: False)\n--group_by_length [GROUP_BY_LENGTH]\n                        Whether or not to group samples of roughly the same length together when batching. (default: False)\n--length_column_name LENGTH_COLUMN_NAME\n                        Column name with precomputed lengths to use when grouping by length. (default: length)\n--report_to REPORT_TO [REPORT_TO ...]\n                        The list of integrations to report the results and logs to. (default: None)\n--ddp_find_unused_parameters DDP_FIND_UNUSED_PARAMETERS\n                        When using distributed training, the value of the flag `find_unused_parameters` passed to `DistributedDataParallel`.\n                        (default: None)\n--ddp_bucket_cap_mb DDP_BUCKET_CAP_MB\n                        When using distributed training, the value of the flag `bucket_cap_mb` passed to `DistributedDataParallel`. (default:\n                        None)\n--ddp_broadcast_buffers DDP_BROADCAST_BUFFERS\n                        When using distributed training, the value of the flag `broadcast_buffers` passed to `DistributedDataParallel`. (default:\n                        None)\n--dataloader_pin_memory [DATALOADER_PIN_MEMORY]\n                        Whether or not to pin memory for DataLoader. (default: True)\n--no_dataloader_pin_memory\n                        Whether or not to pin memory for DataLoader. (default: False)\n--skip_memory_metrics [SKIP_MEMORY_METRICS]\n                        Whether or not to skip adding of memory profiler reports to metrics. (default: True)\n--no_skip_memory_metrics\n                        Whether or not to skip adding of memory profiler reports to metrics. (default: False)\n--use_legacy_prediction_loop [USE_LEGACY_PREDICTION_LOOP]\n                        Whether or not to use the legacy prediction_loop in the Trainer. (default: False)\n--push_to_hub [PUSH_TO_HUB]\n                        Whether or not to upload the trained model to the model hub after training. (default: False)\n--resume_from_checkpoint RESUME_FROM_CHECKPOINT\n                        The path to a folder with a valid checkpoint for your model. (default: None)\n--hub_model_id HUB_MODEL_ID\n                        The name of the repository to keep in sync with the local `output_dir`. (default: None)\n--hub_strategy {end,every_save,checkpoint,all_checkpoints}\n                        The hub strategy to use when `--push_to_hub` is activated. (default: every_save)\n--hub_token HUB_TOKEN\n                        The token to use to push to the Model Hub. (default: None)\n--hub_private_repo [HUB_PRIVATE_REPO]\n                        Whether the model repository is private or not. (default: False)\n--gradient_checkpointing [GRADIENT_CHECKPOINTING]\n                        If True, use gradient checkpointing to save memory at the expense of slower backward pass. (default: False)\n--include_inputs_for_metrics [INCLUDE_INPUTS_FOR_METRICS]\n                        Whether or not the inputs will be passed to the `compute_metrics` function. (default: False)\n--fp16_backend {auto,cuda_amp,apex,cpu_amp}\n                        Deprecated. Use half_precision_backend instead (default: auto)\n--push_to_hub_model_id PUSH_TO_HUB_MODEL_ID\n                        The name of the repository to which push the `Trainer`. (default: None)\n--push_to_hub_organization PUSH_TO_HUB_ORGANIZATION\n                        The name of the organization in with to which push the `Trainer`. (default: None)\n--push_to_hub_token PUSH_TO_HUB_TOKEN\n                        The token to use to push to the Model Hub. (default: None)\n--mp_parameters MP_PARAMETERS\n                        Used by the SageMaker launcher to send mp-specific args. Ignored in Trainer (default: )\n--auto_find_batch_size [AUTO_FIND_BATCH_SIZE]\n                        Whether to automatically decrease the batch size in half and rerun the training loop again each time a CUDA Out-of-Memory\n                        was reached (default: False)\n--full_determinism [FULL_DETERMINISM]\n                        Whether to call enable_full_determinism instead of set_seed for reproducibility in distributed training. Important: this\n                        will negatively impact the performance, so only use it for debugging. (default: False)\n--torchdynamo TORCHDYNAMO\n                        This argument is deprecated, use `--torch_compile_backend` instead. (default: None)\n--ray_scope RAY_SCOPE\n                        The scope to use when doing hyperparameter search with Ray. By default, `\"last\"` will be used. Ray will then use the last\n                        checkpoint of all trials, compare those, and select the best one. However, other options are also available. See the Ray\n                        documentation (https://docs.ray.io/en/latest/tune/api_docs/analysis.html#ray.tune.ExperimentAnalysis.get_best_trial) for\n                        more options. (default: last)\n--ddp_timeout DDP_TIMEOUT\n                        Overrides the default timeout for distributed training (value should be given in seconds). (default: 1800)\n--torch_compile [TORCH_COMPILE]\n                        If set to `True`, the model will be wrapped in `torch.compile`. (default: False)\n--torch_compile_backend TORCH_COMPILE_BACKEND\n                        Which backend to use with `torch.compile`, passing one will trigger a model compilation. (default: None)\n--torch_compile_mode TORCH_COMPILE_MODE\n                        Which mode to use with `torch.compile`, passing one will trigger a model compilation. (default: None)\n--xpu_backend {mpi,ccl,gloo}\n                        The backend to be used for distributed training on Intel XPU. (default: None)\n</code></pre>"},{"location":"data_license.html","title":"Data License","text":"<pre><code># Creative Commons Attribution 4.0 International License (CC BY 4.0)\n\nThis work is licensed under the Creative Commons Attribution 4.0 International License.\n\nTo view a copy of this license, visit http://creativecommons.org/licenses/by/4.0/ or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n</code></pre>"},{"location":"license.html","title":"License","text":"<pre><code>Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright 2023 Emmanuel Noutahi\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n</code></pre>"},{"location":"api/safe.html","title":"SAFE","text":""},{"location":"api/safe.html#safe-encoder-decoder","title":"SAFE Encoder-Decoder","text":""},{"location":"api/safe.html#safe.converter.SAFEConverter","title":"<code>SAFEConverter</code>","text":"<p>Molecule line notation conversion from SMILES to SAFE</p> <p>A SAFE representation is a string based representation of a molecule decomposition into fragment components, separated by a dot ('.'). Note that each component (fragment) might not be a valid molecule by themselves, unless explicitely correct to add missing hydrogens.</p> <p>Slicing algorithms</p> <p>By default SAFE strings are generated using <code>BRICS</code>, however, the following alternative are supported:</p> <ul> <li>Hussain-Rea (<code>hr</code>)</li> <li>RECAP (<code>recap</code>)</li> <li>RDKit's MMPA (<code>mmpa</code>)</li> <li>Any possible attachment points (<code>attach</code>)</li> </ul> <p>Furthermore, you can also provide your own slicing algorithm, which should return a pair of atoms corresponding to the bonds to break.</p> Source code in <code>safe/converter.py</code> <pre><code>class SAFEConverter:\n    \"\"\"Molecule line notation conversion from SMILES to SAFE\n\n    A SAFE representation is a string based representation of a molecule decomposition into fragment components,\n    separated by a dot ('.'). Note that each component (fragment) might not be a valid molecule by themselves,\n    unless explicitely correct to add missing hydrogens.\n\n    !!! note \"Slicing algorithms\"\n\n        By default SAFE strings are generated using `BRICS`, however, the following alternative are supported:\n\n        * [Hussain-Rea (`hr`)](https://pubs.acs.org/doi/10.1021/ci900450m)\n        * [RECAP (`recap`)](https://pubmed.ncbi.nlm.nih.gov/9611787/)\n        * [RDKit's MMPA (`mmpa`)](https://www.rdkit.org/docs/source/rdkit.Chem.rdMMPA.html)\n        * Any possible attachment points (`attach`)\n\n        Furthermore, you can also provide your own slicing algorithm, which should return a pair of atoms\n        corresponding to the bonds to break.\n\n    \"\"\"\n\n    SUPPORTED_SLICERS = [\"hr\", \"recap\", \"mmpa\", \"attach\", \"brics\"]\n    __SLICE_SMARTS = {\n        \"hr\": [\"[*]!@-[*]\"],  # any non ring single bond\n        \"recap\": [\n            \"[C;$(C=O)]!@-N\",  # amides and urea\n            \"[C;$(C=O)]!@-O\",  # esters\n            \"C!@-[N;!$(NC=O)]\",  # amines\n            \"C!@-[O;!$(NC=O)]\",  # ether\n            \"[CX3]!@=[CX3]\",  # olefin\n            \"[N+X4]!@-C\",  # quaternary nitrogen\n            \"n!@-C\",  # aromatic N - aliphatic C\n            \"[$([NR][CR]=O)]!@-C\",  # lactam nitrogen - aliphatic carbon\n            \"c!@-c\",  # aromatic C - aromatic C\n            \"N!@-[$(S(=O)=O)]\",  # sulphonamides\n        ],\n        \"mmpa\": [\"[#6+0;!$(*=,#[!#6])]!@!=!#[*]\"],  # classical mmpa slicing smarts\n        \"attach\": [\"[*]!@[*]\"],  # any potential attachment point, including hydrogens when explicit\n    }\n\n    def __init__(\n        self,\n        slicer: Optional[Union[str, List[str], Callable]] = \"brics\",\n        require_hs: Optional[bool] = None,\n    ):\n        \"\"\"Constructor for the SAFE converter\n\n        Args:\n            slicer: slicer algorithm to use for encoding.\n                Can either be one of the supported slicing algorithm (SUPPORTED_SLICERS)\n                or a custom callable that returns the bond ids that can be sliced.\n            require_hs: whether the slicing algorithm require the molecule to have hydrogen explictly added.\n                `attach` slicer requires adding hydrogens.\n\n        \"\"\"\n        self.slicer = slicer\n        if isinstance(slicer, str) and slicer.lower() in self.SUPPORTED_SLICERS:\n            self.slicer = self.__SLICE_SMARTS.get(slicer.lower(), slicer)\n        if self.slicer != \"brics\" and isinstance(self.slicer, str):\n            self.slicer = [self.slicer]\n        if isinstance(self.slicer, (list, tuple)):\n            self.slicer = [dm.from_smarts(x) for x in self.slicer]\n        self.require_hs = require_hs or (slicer == \"attach\")\n\n    @staticmethod\n    def randomize(mol: dm.Mol, rng: Optional[int] = None):\n        \"\"\"Randomize the position of the atoms in a mol.\n\n        Args:\n            mol: molecules to randomize\n            rng: optional seed to use\n        \"\"\"\n        if isinstance(rng, int):\n            rng = np.random.default_rng(rng)\n        if mol.GetNumAtoms() == 0:\n            return mol\n        atom_indices = list(range(mol.GetNumAtoms()))\n        atom_indices = rng.permutation(atom_indices).tolist()\n        return Chem.RenumberAtoms(mol, atom_indices)\n\n    @classmethod\n    def _find_branch_number(cls, inp: str):\n        \"\"\"Find the branch number and ring closure in the SMILES representation using regexp\n\n        Args:\n            inp: input smiles\n        \"\"\"\n\n        matching_groups = re.findall(r\"((?&lt;=%)\\d{2})|((?&lt;!%)\\d+)\", inp)\n        # first match is for multiple connection as multiple digits\n        # second match is for single connections requiring 2 digits\n        # SMILES does not support triple digits\n        branch_numbers = []\n        for m in matching_groups:\n            if m[0] == \"\":\n                branch_numbers.extend(int(mm) for mm in m[1])\n            elif m[1] == \"\":\n                branch_numbers.append(int(m[0].replace(\"%\", \"\")))\n        return branch_numbers\n\n    def _ensure_valid(self, inp: str):\n        \"\"\"Ensure that the input SAFE string is valid by fixing the missing attachment points\n\n        Args:\n            inp: input SAFE string\n        \"\"\"\n        missing_tokens = [inp]\n        branch_numbers = self._find_branch_number(inp)\n        # only use the set that have exactly 1 element\n        # any branch number that is not pairwise should receive a dummy atom to complete the attachment point\n        branch_numbers = Counter(branch_numbers)\n        for i, (bnum, bcount) in enumerate(branch_numbers.items()):\n            if bcount % 2 != 0:\n                bnum_str = str(bnum) if bnum &lt; 10 else f\"%{bnum}\"\n                missing_tokens.append(f\"[*:{i+1}]{bnum_str}\")\n\n        return \".\".join(missing_tokens)\n\n    def decoder(\n        self,\n        inp: str,\n        as_mol: bool = False,\n        canonical: bool = False,\n        fix: bool = True,\n        remove_dummies: bool = True,\n        remove_added_hs: bool = True,\n    ):\n        \"\"\"Convert input SAFE representation to smiles\n\n        Args:\n            inp: input SAFE representation to decode as a valid molecule or smiles\n            as_mol: whether to return a molecule object or a smiles string\n            canonical: whether to return a canonical\n            fix: whether to fix the SAFE representation to take into account non-connected attachment points\n            remove_dummies: whether to remove dummy atoms from the SAFE representation. Note that removing_dummies is incompatible with\n            remove_added_hs: whether to remove all the added hydrogen atoms after applying dummy removal for recovery\n        \"\"\"\n\n        if fix:\n            inp = self._ensure_valid(inp)\n        mol = dm.to_mol(inp)\n        if remove_dummies:\n            with suppress(Exception):\n                du = dm.from_smarts(\"[$([#0]!-!:*);$([#0;D1])]\")\n                out = Chem.ReplaceSubstructs(mol, du, dm.to_mol(\"C\"), True)[0]\n                mol = dm.remove_dummies(out)\n        if as_mol:\n            if remove_added_hs:\n                mol = dm.remove_hs(mol, update_explicit_count=True)\n            if canonical:\n                mol = dm.standardize_mol(mol)\n                mol = dm.canonical_tautomer(mol)\n            return mol\n        out = dm.to_smiles(mol, canonical=canonical, explicit_hs=(not remove_added_hs))\n        if canonical:\n            out = dm.standardize_smiles(out)\n        return out\n\n    def _fragment(self, mol: dm.Mol, allow_empty: bool = False):\n        \"\"\"\n        Perform bond cutting in place for the input molecule, given the slicing algorithm\n\n        Args:\n            mol: input molecule to split\n            allow_empty: whether to allow the slicing algorithm to return empty bonds\n        Raises:\n            SAFEFragmentationError: if the slicing algorithm return empty bonds\n        \"\"\"\n\n        if self.slicer is None:\n            matching_bonds = []\n\n        elif callable(self.slicer):\n            matching_bonds = self.slicer(mol)\n\n        elif self.slicer == \"brics\":\n            matching_bonds = BRICS.FindBRICSBonds(mol)\n            matching_bonds = [brics_match[0] for brics_match in matching_bonds]\n\n        else:\n            matches = set()\n            for smarts in self.slicer:\n                matches |= {\n                    tuple(sorted(match)) for match in mol.GetSubstructMatches(smarts, uniquify=True)\n                }\n            matching_bonds = list(matches)\n\n        if matching_bonds is None or len(matching_bonds) == 0 and not allow_empty:\n            raise SAFEFragmentationError(\n                \"Slicing algorithms did not return any bonds that can be cut !\"\n            )\n        return matching_bonds or []\n\n    def encoder(\n        self,\n        inp: Union[str, dm.Mol],\n        canonical: bool = True,\n        randomize: Optional[bool] = False,\n        seed: Optional[int] = None,\n        constraints: Optional[List[dm.Mol]] = None,\n        allow_empty: bool = False,\n    ):\n        \"\"\"Convert input smiles to SAFE representation\n\n        Args:\n            inp: input smiles\n            canonical: whether to return canonical smiles string. Defaults to True\n            randomize: whether to randomize the safe string encoding. Will be ignored if canonical is provided\n            seed: optional seed to use when allowing randomization of the SAFE encoding.\n                Randomization happens at two steps:\n                1. at the original smiles representation by randomization the atoms.\n                2. at the SAFE conversion by randomizing fragment orders\n            constraints: List of molecules or pattern to preserve during the SAFE construction. Any bond slicing would\n                happen outside of a substructure matching one of the patterns.\n            allow_empty: whether to allow the slicing algorithm to return empty bonds\n        \"\"\"\n        rng = None\n        if randomize:\n            rng = np.random.default_rng(seed)\n            if not canonical:\n                inp = dm.to_mol(inp, remove_hs=False)\n                inp = self.randomize(inp, rng)\n\n        if isinstance(inp, dm.Mol):\n            inp = dm.to_smiles(inp, canonical=canonical, randomize=False, ordered=False)\n\n        # EN: we first normalize the attachment if the molecule is a query:\n        # inp = dm.reactions.convert_attach_to_isotope(inp, as_smiles=True)\n\n        # TODO(maclandrol): RDKit supports some extended form of ring closure, up to 5 digits\n        # https://www.rdkit.org/docs/RDKit_Book.html#ring-closures and I should try to include them\n        branch_numbers = self._find_branch_number(inp)\n        mol = dm.to_mol(inp, remove_hs=False)\n\n        bond_map_id = 1\n        for atom in mol.GetAtoms():\n            if atom.GetAtomicNum() == 0:\n                atom.SetAtomMapNum(0)\n                atom.SetIsotope(bond_map_id)\n                bond_map_id += 1\n\n        if self.require_hs:\n            mol = dm.add_hs(mol)\n        matching_bonds = self._fragment(mol, allow_empty=allow_empty)\n        substructed_ignored = []\n        if constraints is not None:\n            substructed_ignored = list(\n                itertools.chain(\n                    *[\n                        mol.GetSubstructMatches(constraint, uniquify=True)\n                        for constraint in constraints\n                    ]\n                )\n            )\n\n        bonds = []\n        for i_a, i_b in matching_bonds:\n            # if both atoms of the bond are found in a disallowed substructure, we cannot consider them\n            # on the other end, a bond between two substructure to preserved independently is perfectly fine\n            if any((i_a in ignore_x and i_b in ignore_x) for ignore_x in substructed_ignored):\n                continue\n            obond = mol.GetBondBetweenAtoms(i_a, i_b)\n            bonds.append(obond.GetIdx())\n        if len(bonds) &gt; 0:\n            mol = Chem.FragmentOnBonds(\n                mol,\n                bonds,\n                dummyLabels=[(i + bond_map_id, i + bond_map_id) for i in range(len(bonds))],\n            )\n        # here we need to be clever and disable rooted atom as the atom with mapping\n\n        frags = list(Chem.GetMolFrags(mol, asMols=True))\n\n        if randomize:\n            frags = rng.permutation(frags).tolist()\n        elif canonical:\n            frags = sorted(\n                frags,\n                key=lambda x: x.GetNumAtoms(),\n                reverse=True,\n            )\n\n        frags_str = []\n        for frag in frags:\n            non_map_atom_idxs = [\n                atom.GetIdx() for atom in frag.GetAtoms() if atom.GetAtomicNum() != 0\n            ]\n            frags_str.append(\n                Chem.MolToSmiles(\n                    frag,\n                    isomericSmiles=True,\n                    canonical=True,  # needs to always be true\n                    rootedAtAtom=non_map_atom_idxs[0],\n                )\n            )\n\n        scaffold_str = \".\".join(frags_str)\n        attach_pos = set(re.findall(r\"(\\[\\d+\\*\\]|\\[[^:]*:\\d+\\])\", scaffold_str))\n        starting_num = 1 if len(branch_numbers) == 0 else max(branch_numbers) + 1\n        for attach in attach_pos:\n            val = str(starting_num) if starting_num &lt; 10 else f\"%{starting_num}\"\n            # we cannot have anything of the form \"\\([@=-#-$/\\]*\\d+\\)\"\n            attach_regexp = re.compile(r\"(\" + re.escape(attach) + r\")\")\n            scaffold_str = attach_regexp.sub(val, scaffold_str)\n            starting_num += 1\n        # now we need to remove all the parenthesis around difig only number\n        wrong_attach = re.compile(r\"\\(([\\%\\d]*)\\)\")\n        return wrong_attach.sub(r\"\\g&lt;1&gt;\", scaffold_str)\n</code></pre>"},{"location":"api/safe.html#safe.converter.SAFEConverter.__init__","title":"<code>__init__(slicer='brics', require_hs=None)</code>","text":"<p>Constructor for the SAFE converter</p> <p>Parameters:</p> Name Type Description Default <code>slicer</code> <code>Optional[Union[str, List[str], Callable]]</code> <p>slicer algorithm to use for encoding. Can either be one of the supported slicing algorithm (SUPPORTED_SLICERS) or a custom callable that returns the bond ids that can be sliced.</p> <code>'brics'</code> <code>require_hs</code> <code>Optional[bool]</code> <p>whether the slicing algorithm require the molecule to have hydrogen explictly added. <code>attach</code> slicer requires adding hydrogens.</p> <code>None</code> Source code in <code>safe/converter.py</code> <pre><code>def __init__(\n    self,\n    slicer: Optional[Union[str, List[str], Callable]] = \"brics\",\n    require_hs: Optional[bool] = None,\n):\n    \"\"\"Constructor for the SAFE converter\n\n    Args:\n        slicer: slicer algorithm to use for encoding.\n            Can either be one of the supported slicing algorithm (SUPPORTED_SLICERS)\n            or a custom callable that returns the bond ids that can be sliced.\n        require_hs: whether the slicing algorithm require the molecule to have hydrogen explictly added.\n            `attach` slicer requires adding hydrogens.\n\n    \"\"\"\n    self.slicer = slicer\n    if isinstance(slicer, str) and slicer.lower() in self.SUPPORTED_SLICERS:\n        self.slicer = self.__SLICE_SMARTS.get(slicer.lower(), slicer)\n    if self.slicer != \"brics\" and isinstance(self.slicer, str):\n        self.slicer = [self.slicer]\n    if isinstance(self.slicer, (list, tuple)):\n        self.slicer = [dm.from_smarts(x) for x in self.slicer]\n    self.require_hs = require_hs or (slicer == \"attach\")\n</code></pre>"},{"location":"api/safe.html#safe.converter.SAFEConverter.decoder","title":"<code>decoder(inp, as_mol=False, canonical=False, fix=True, remove_dummies=True, remove_added_hs=True)</code>","text":"<p>Convert input SAFE representation to smiles</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>str</code> <p>input SAFE representation to decode as a valid molecule or smiles</p> required <code>as_mol</code> <code>bool</code> <p>whether to return a molecule object or a smiles string</p> <code>False</code> <code>canonical</code> <code>bool</code> <p>whether to return a canonical</p> <code>False</code> <code>fix</code> <code>bool</code> <p>whether to fix the SAFE representation to take into account non-connected attachment points</p> <code>True</code> <code>remove_dummies</code> <code>bool</code> <p>whether to remove dummy atoms from the SAFE representation. Note that removing_dummies is incompatible with</p> <code>True</code> <code>remove_added_hs</code> <code>bool</code> <p>whether to remove all the added hydrogen atoms after applying dummy removal for recovery</p> <code>True</code> Source code in <code>safe/converter.py</code> <pre><code>def decoder(\n    self,\n    inp: str,\n    as_mol: bool = False,\n    canonical: bool = False,\n    fix: bool = True,\n    remove_dummies: bool = True,\n    remove_added_hs: bool = True,\n):\n    \"\"\"Convert input SAFE representation to smiles\n\n    Args:\n        inp: input SAFE representation to decode as a valid molecule or smiles\n        as_mol: whether to return a molecule object or a smiles string\n        canonical: whether to return a canonical\n        fix: whether to fix the SAFE representation to take into account non-connected attachment points\n        remove_dummies: whether to remove dummy atoms from the SAFE representation. Note that removing_dummies is incompatible with\n        remove_added_hs: whether to remove all the added hydrogen atoms after applying dummy removal for recovery\n    \"\"\"\n\n    if fix:\n        inp = self._ensure_valid(inp)\n    mol = dm.to_mol(inp)\n    if remove_dummies:\n        with suppress(Exception):\n            du = dm.from_smarts(\"[$([#0]!-!:*);$([#0;D1])]\")\n            out = Chem.ReplaceSubstructs(mol, du, dm.to_mol(\"C\"), True)[0]\n            mol = dm.remove_dummies(out)\n    if as_mol:\n        if remove_added_hs:\n            mol = dm.remove_hs(mol, update_explicit_count=True)\n        if canonical:\n            mol = dm.standardize_mol(mol)\n            mol = dm.canonical_tautomer(mol)\n        return mol\n    out = dm.to_smiles(mol, canonical=canonical, explicit_hs=(not remove_added_hs))\n    if canonical:\n        out = dm.standardize_smiles(out)\n    return out\n</code></pre>"},{"location":"api/safe.html#safe.converter.SAFEConverter.encoder","title":"<code>encoder(inp, canonical=True, randomize=False, seed=None, constraints=None, allow_empty=False)</code>","text":"<p>Convert input smiles to SAFE representation</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>Union[str, Mol]</code> <p>input smiles</p> required <code>canonical</code> <code>bool</code> <p>whether to return canonical smiles string. Defaults to True</p> <code>True</code> <code>randomize</code> <code>Optional[bool]</code> <p>whether to randomize the safe string encoding. Will be ignored if canonical is provided</p> <code>False</code> <code>seed</code> <code>Optional[int]</code> <p>optional seed to use when allowing randomization of the SAFE encoding. Randomization happens at two steps: 1. at the original smiles representation by randomization the atoms. 2. at the SAFE conversion by randomizing fragment orders</p> <code>None</code> <code>constraints</code> <code>Optional[List[Mol]]</code> <p>List of molecules or pattern to preserve during the SAFE construction. Any bond slicing would happen outside of a substructure matching one of the patterns.</p> <code>None</code> <code>allow_empty</code> <code>bool</code> <p>whether to allow the slicing algorithm to return empty bonds</p> <code>False</code> Source code in <code>safe/converter.py</code> <pre><code>def encoder(\n    self,\n    inp: Union[str, dm.Mol],\n    canonical: bool = True,\n    randomize: Optional[bool] = False,\n    seed: Optional[int] = None,\n    constraints: Optional[List[dm.Mol]] = None,\n    allow_empty: bool = False,\n):\n    \"\"\"Convert input smiles to SAFE representation\n\n    Args:\n        inp: input smiles\n        canonical: whether to return canonical smiles string. Defaults to True\n        randomize: whether to randomize the safe string encoding. Will be ignored if canonical is provided\n        seed: optional seed to use when allowing randomization of the SAFE encoding.\n            Randomization happens at two steps:\n            1. at the original smiles representation by randomization the atoms.\n            2. at the SAFE conversion by randomizing fragment orders\n        constraints: List of molecules or pattern to preserve during the SAFE construction. Any bond slicing would\n            happen outside of a substructure matching one of the patterns.\n        allow_empty: whether to allow the slicing algorithm to return empty bonds\n    \"\"\"\n    rng = None\n    if randomize:\n        rng = np.random.default_rng(seed)\n        if not canonical:\n            inp = dm.to_mol(inp, remove_hs=False)\n            inp = self.randomize(inp, rng)\n\n    if isinstance(inp, dm.Mol):\n        inp = dm.to_smiles(inp, canonical=canonical, randomize=False, ordered=False)\n\n    # EN: we first normalize the attachment if the molecule is a query:\n    # inp = dm.reactions.convert_attach_to_isotope(inp, as_smiles=True)\n\n    # TODO(maclandrol): RDKit supports some extended form of ring closure, up to 5 digits\n    # https://www.rdkit.org/docs/RDKit_Book.html#ring-closures and I should try to include them\n    branch_numbers = self._find_branch_number(inp)\n    mol = dm.to_mol(inp, remove_hs=False)\n\n    bond_map_id = 1\n    for atom in mol.GetAtoms():\n        if atom.GetAtomicNum() == 0:\n            atom.SetAtomMapNum(0)\n            atom.SetIsotope(bond_map_id)\n            bond_map_id += 1\n\n    if self.require_hs:\n        mol = dm.add_hs(mol)\n    matching_bonds = self._fragment(mol, allow_empty=allow_empty)\n    substructed_ignored = []\n    if constraints is not None:\n        substructed_ignored = list(\n            itertools.chain(\n                *[\n                    mol.GetSubstructMatches(constraint, uniquify=True)\n                    for constraint in constraints\n                ]\n            )\n        )\n\n    bonds = []\n    for i_a, i_b in matching_bonds:\n        # if both atoms of the bond are found in a disallowed substructure, we cannot consider them\n        # on the other end, a bond between two substructure to preserved independently is perfectly fine\n        if any((i_a in ignore_x and i_b in ignore_x) for ignore_x in substructed_ignored):\n            continue\n        obond = mol.GetBondBetweenAtoms(i_a, i_b)\n        bonds.append(obond.GetIdx())\n    if len(bonds) &gt; 0:\n        mol = Chem.FragmentOnBonds(\n            mol,\n            bonds,\n            dummyLabels=[(i + bond_map_id, i + bond_map_id) for i in range(len(bonds))],\n        )\n    # here we need to be clever and disable rooted atom as the atom with mapping\n\n    frags = list(Chem.GetMolFrags(mol, asMols=True))\n\n    if randomize:\n        frags = rng.permutation(frags).tolist()\n    elif canonical:\n        frags = sorted(\n            frags,\n            key=lambda x: x.GetNumAtoms(),\n            reverse=True,\n        )\n\n    frags_str = []\n    for frag in frags:\n        non_map_atom_idxs = [\n            atom.GetIdx() for atom in frag.GetAtoms() if atom.GetAtomicNum() != 0\n        ]\n        frags_str.append(\n            Chem.MolToSmiles(\n                frag,\n                isomericSmiles=True,\n                canonical=True,  # needs to always be true\n                rootedAtAtom=non_map_atom_idxs[0],\n            )\n        )\n\n    scaffold_str = \".\".join(frags_str)\n    attach_pos = set(re.findall(r\"(\\[\\d+\\*\\]|\\[[^:]*:\\d+\\])\", scaffold_str))\n    starting_num = 1 if len(branch_numbers) == 0 else max(branch_numbers) + 1\n    for attach in attach_pos:\n        val = str(starting_num) if starting_num &lt; 10 else f\"%{starting_num}\"\n        # we cannot have anything of the form \"\\([@=-#-$/\\]*\\d+\\)\"\n        attach_regexp = re.compile(r\"(\" + re.escape(attach) + r\")\")\n        scaffold_str = attach_regexp.sub(val, scaffold_str)\n        starting_num += 1\n    # now we need to remove all the parenthesis around difig only number\n    wrong_attach = re.compile(r\"\\(([\\%\\d]*)\\)\")\n    return wrong_attach.sub(r\"\\g&lt;1&gt;\", scaffold_str)\n</code></pre>"},{"location":"api/safe.html#safe.converter.SAFEConverter.randomize","title":"<code>randomize(mol, rng=None)</code>  <code>staticmethod</code>","text":"<p>Randomize the position of the atoms in a mol.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>molecules to randomize</p> required <code>rng</code> <code>Optional[int]</code> <p>optional seed to use</p> <code>None</code> Source code in <code>safe/converter.py</code> <pre><code>@staticmethod\ndef randomize(mol: dm.Mol, rng: Optional[int] = None):\n    \"\"\"Randomize the position of the atoms in a mol.\n\n    Args:\n        mol: molecules to randomize\n        rng: optional seed to use\n    \"\"\"\n    if isinstance(rng, int):\n        rng = np.random.default_rng(rng)\n    if mol.GetNumAtoms() == 0:\n        return mol\n    atom_indices = list(range(mol.GetNumAtoms()))\n    atom_indices = rng.permutation(atom_indices).tolist()\n    return Chem.RenumberAtoms(mol, atom_indices)\n</code></pre>"},{"location":"api/safe.html#safe.converter.encode","title":"<code>encode(inp, canonical=True, randomize=False, seed=None, slicer=None, require_hs=None, constraints=None)</code>","text":"<p>Convert input smiles to SAFE representation</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>Union[str, Mol]</code> <p>input smiles</p> required <code>canonical</code> <code>bool</code> <p>whether to return canonical SAFE string. Defaults to True</p> <code>True</code> <code>randomize</code> <code>Optional[bool]</code> <p>whether to randomize the safe string encoding. Will be ignored if canonical is provided</p> <code>False</code> <code>seed</code> <code>Optional[int]</code> <p>optional seed to use when allowing randomization of the SAFE encoding.</p> <code>None</code> <code>slicer</code> <code>Optional[Union[str, Callable]]</code> <p>slicer algorithm to use for encoding. Defaults to \"brics\".</p> <code>None</code> <code>require_hs</code> <code>Optional[bool]</code> <p>whether the slicing algorithm require the molecule to have hydrogen explictly added.</p> <code>None</code> <code>constraints</code> <code>Optional[List[Mol]]</code> <p>List of molecules or pattern to preserve during the SAFE construction.</p> <code>None</code> Source code in <code>safe/converter.py</code> <pre><code>def encode(\n    inp: Union[str, dm.Mol],\n    canonical: bool = True,\n    randomize: Optional[bool] = False,\n    seed: Optional[int] = None,\n    slicer: Optional[Union[str, Callable]] = None,\n    require_hs: Optional[bool] = None,\n    constraints: Optional[List[dm.Mol]] = None,\n):\n    \"\"\"\n    Convert input smiles to SAFE representation\n\n    Args:\n        inp: input smiles\n        canonical: whether to return canonical SAFE string. Defaults to True\n        randomize: whether to randomize the safe string encoding. Will be ignored if canonical is provided\n        seed: optional seed to use when allowing randomization of the SAFE encoding.\n        slicer: slicer algorithm to use for encoding. Defaults to \"brics\".\n        require_hs: whether the slicing algorithm require the molecule to have hydrogen explictly added.\n        constraints: List of molecules or pattern to preserve during the SAFE construction.\n    \"\"\"\n    if slicer is None:\n        slicer = \"brics\"\n    with dm.without_rdkit_log():\n        safe_obj = SAFEConverter(slicer=slicer, require_hs=require_hs)\n        try:\n            encoded = safe_obj.encoder(\n                inp, canonical=canonical, randomize=randomize, constraints=constraints, seed=seed\n            )\n        except SAFEFragmentationError as e:\n            raise e\n        except Exception as e:\n            raise SAFEEncodeError(f\"Failed to encode {inp} with {slicer}\") from e\n        return encoded\n</code></pre>"},{"location":"api/safe.html#safe.converter.decode","title":"<code>decode(safe_str, as_mol=False, canonical=False, fix=True, remove_added_hs=True, remove_dummies=True, ignore_errors=False)</code>","text":"<p>Convert input SAFE representation to smiles Args:     inp: input SAFE representation to decode as a valid molecule or smiles     as_mol: whether to return a molecule object or a smiles string     canonical: whether to return a canonical smiles or a randomized smiles     standardize: whether to standardize the molecule     fix: whether to fix the SAFE representation to take into account non-connected attachment points     remove_added_hs: whether to remove the hydrogen atoms that have been added to fix the string.     remove_dummies: whether to remove dummy atoms from the SAFE representation     ignore_errors: whether to ignore error and return None on decoding failure or raise an error</p> Source code in <code>safe/converter.py</code> <pre><code>def decode(\n    safe_str: str,\n    as_mol: bool = False,\n    canonical: bool = False,\n    fix: bool = True,\n    remove_added_hs: bool = True,\n    remove_dummies: bool = True,\n    ignore_errors: bool = False,\n):\n    \"\"\"Convert input SAFE representation to smiles\n    Args:\n        inp: input SAFE representation to decode as a valid molecule or smiles\n        as_mol: whether to return a molecule object or a smiles string\n        canonical: whether to return a canonical smiles or a randomized smiles\n        standardize: whether to standardize the molecule\n        fix: whether to fix the SAFE representation to take into account non-connected attachment points\n        remove_added_hs: whether to remove the hydrogen atoms that have been added to fix the string.\n        remove_dummies: whether to remove dummy atoms from the SAFE representation\n        ignore_errors: whether to ignore error and return None on decoding failure or raise an error\n\n    \"\"\"\n    with dm.without_rdkit_log():\n        safe_obj = SAFEConverter()\n        try:\n            decoded = safe_obj.decoder(\n                safe_str,\n                as_mol=as_mol,\n                canonical=canonical,\n                fix=fix,\n                remove_dummies=remove_dummies,\n                remove_added_hs=remove_added_hs,\n            )\n\n        except Exception as e:\n            if ignore_errors:\n                return None\n            raise SAFEDecodeError(f\"Failed to decode {safe_str}\") from e\n        return decoded\n</code></pre>"},{"location":"api/safe.html#safe-tokenizer","title":"SAFE Tokenizer","text":""},{"location":"api/safe.html#safe.tokenizer.SAFESplitter","title":"<code>SAFESplitter</code>","text":"<p>Standard Splitter for SAFE string</p> Source code in <code>safe/tokenizer.py</code> <pre><code>class SAFESplitter:\n    \"\"\"Standard Splitter for SAFE string\"\"\"\n\n    REGEX_PATTERN = r\"\"\"(\\[[^\\]]+]|Br?|Cl?|N|O|S|P|F|I|b|c|n|o|s|p|\\(|\\)|\\.|=|#|-|\\+|\\\\|\\/|:|~|@|\\?|&gt;&gt;?|\\*|\\$|\\%[0-9]{2}|[0-9])\"\"\"\n\n    name = \"smiles\"\n\n    def __init__(self, pattern: Optional[str] = None):\n        # do not use this as raw strings (not r before)\n        if pattern is None:\n            pattern = self.REGEX_PATTERN\n        self.regex = re.compile(pattern)\n\n    def tokenize(self, line):\n        \"\"\"Tokenize a molecule into SMILES.\"\"\"\n        if isinstance(line, str):\n            tokens = list(self.regex.findall(line))\n            reconstruction = \"\".join(tokens)\n            if line != reconstruction:\n                logger.error(\n                    f\"Tokens different from sample:\\ntokens {reconstruction}\\nsample {line}.\"\n                )\n                raise ValueError(line)\n        else:\n            idxs = re.finditer(self.regex, str(line))\n            tokens = [line[m.start(0) : m.end(0)] for m in idxs]\n        return tokens\n\n    def detokenize(self, chars):\n        \"\"\"Detokenize SAFE notation\"\"\"\n        if isinstance(chars, str):\n            chars = chars.split(\" \")\n        return \"\".join([x.strip() for x in chars])\n\n    def split(self, n, normalized):\n        \"\"\"Perform splitting for pretokenization\"\"\"\n        return self.tokenize(normalized)\n\n    def pre_tokenize(self, pretok):\n        \"\"\"Pretokenize using an input pretokenizer\"\"\"\n        pretok.split(self.split)\n</code></pre>"},{"location":"api/safe.html#safe.tokenizer.SAFESplitter.detokenize","title":"<code>detokenize(chars)</code>","text":"<p>Detokenize SAFE notation</p> Source code in <code>safe/tokenizer.py</code> <pre><code>def detokenize(self, chars):\n    \"\"\"Detokenize SAFE notation\"\"\"\n    if isinstance(chars, str):\n        chars = chars.split(\" \")\n    return \"\".join([x.strip() for x in chars])\n</code></pre>"},{"location":"api/safe.html#safe.tokenizer.SAFESplitter.pre_tokenize","title":"<code>pre_tokenize(pretok)</code>","text":"<p>Pretokenize using an input pretokenizer</p> Source code in <code>safe/tokenizer.py</code> <pre><code>def pre_tokenize(self, pretok):\n    \"\"\"Pretokenize using an input pretokenizer\"\"\"\n    pretok.split(self.split)\n</code></pre>"},{"location":"api/safe.html#safe.tokenizer.SAFESplitter.split","title":"<code>split(n, normalized)</code>","text":"<p>Perform splitting for pretokenization</p> Source code in <code>safe/tokenizer.py</code> <pre><code>def split(self, n, normalized):\n    \"\"\"Perform splitting for pretokenization\"\"\"\n    return self.tokenize(normalized)\n</code></pre>"},{"location":"api/safe.html#safe.tokenizer.SAFESplitter.tokenize","title":"<code>tokenize(line)</code>","text":"<p>Tokenize a molecule into SMILES.</p> Source code in <code>safe/tokenizer.py</code> <pre><code>def tokenize(self, line):\n    \"\"\"Tokenize a molecule into SMILES.\"\"\"\n    if isinstance(line, str):\n        tokens = list(self.regex.findall(line))\n        reconstruction = \"\".join(tokens)\n        if line != reconstruction:\n            logger.error(\n                f\"Tokens different from sample:\\ntokens {reconstruction}\\nsample {line}.\"\n            )\n            raise ValueError(line)\n    else:\n        idxs = re.finditer(self.regex, str(line))\n        tokens = [line[m.start(0) : m.end(0)] for m in idxs]\n    return tokens\n</code></pre>"},{"location":"api/safe.html#safe.tokenizer.SAFETokenizer","title":"<code>SAFETokenizer</code>","text":"<p>Class to initialize and train a tokenizer for SAFE string Once trained, you can use the converted version of the tokenizer to an HuggingFace PreTrainedTokenizerFast</p> Source code in <code>safe/tokenizer.py</code> <pre><code>class SAFETokenizer:\n    \"\"\"\n    Class to initialize and train a tokenizer for SAFE string\n    Once trained, you can use the converted version of the tokenizer to an HuggingFace PreTrainedTokenizerFast\n    \"\"\"\n\n    def __init__(\n        self,\n        tokenizer_type: str = \"bpe\",\n        splitter: Optional[str] = \"safe\",\n        trainer_args=None,\n        decoder_args=None,\n        token_model_args=None,\n    ):\n        super().__init__()\n        self.tokenizer_type = tokenizer_type\n        self.trainer_args = trainer_args or {}\n        self.decoder_args = decoder_args or {}\n        self.token_model_args = token_model_args or {}\n        if tokenizer_type is not None and tokenizer_type.startswith(\"bpe\"):\n            self.model = BPE(unk_token=UNK_TOKEN, **self.token_model_args)\n            self.trainer = BpeTrainer(special_tokens=SPECIAL_TOKENS, **self.trainer_args)\n\n        else:\n            self.model = WordLevel(unk_token=UNK_TOKEN, **self.token_model_args)\n            self.trainer = WordLevelTrainer(special_tokens=SPECIAL_TOKENS, **self.trainer_args)\n\n        self.tokenizer = Tokenizer(self.model)\n        self.splitter = None\n        if splitter == \"safe\":\n            self.splitter = SAFESplitter()\n            self.tokenizer.pre_tokenizer = PreTokenizer.custom(self.splitter)\n        self.tokenizer.post_processor = TemplateProcessing(\n            single=TEMPLATE_SINGLE,\n            pair=TEMPLATE_PAIR,\n            special_tokens=TEMPLATE_SPECIAL_TOKENS,\n        )\n        self.tokenizer.decoder = decoders.BPEDecoder(**self.decoder_args)\n        self.tokenizer = self.set_special_tokens(self.tokenizer)\n\n    @property\n    def bos_token_id(self):\n        \"\"\"Get the bos token id\"\"\"\n        return self.tokenizer.token_to_id(self.tokenizer.bos_token)\n\n    @property\n    def pad_token_id(self):\n        \"\"\"Get the bos token id\"\"\"\n        return self.tokenizer.token_to_id(self.tokenizer.pad_token)\n\n    @property\n    def eos_token_id(self):\n        \"\"\"Get the bos token id\"\"\"\n        return self.tokenizer.token_to_id(self.tokenizer.eos_token)\n\n    @classmethod\n    def set_special_tokens(\n        cls,\n        tokenizer: Tokenizer,\n        bos_token: str = CLS_TOKEN,\n        eos_token: str = SEP_TOKEN,\n    ):\n        \"\"\"Set special tokens for a tokenizer\n\n        Args:\n            tokenizer: tokenizer for which special tokens will be set\n            bos_token: Optional bos token to use\n            eos_token: Optional eos token to use\n        \"\"\"\n        tokenizer.pad_token = PADDING_TOKEN\n        tokenizer.cls_token = CLS_TOKEN\n        tokenizer.sep_token = SEP_TOKEN\n        tokenizer.mask_token = MASK_TOKEN\n        tokenizer.unk_token = UNK_TOKEN\n        tokenizer.eos_token = eos_token\n        tokenizer.bos_token = bos_token\n\n        if isinstance(tokenizer, Tokenizer):\n            tokenizer.add_special_tokens(\n                [\n                    PADDING_TOKEN,\n                    CLS_TOKEN,\n                    SEP_TOKEN,\n                    MASK_TOKEN,\n                    UNK_TOKEN,\n                    eos_token,\n                    bos_token,\n                ]\n            )\n        return tokenizer\n\n    def train(self, files: Optional[List[str]], **kwargs):\n        r\"\"\"\n        This is to train a new tokenizer from either a list of file or some input data\n\n        Args\n            files (str): file in which your molecules are separated by new line\n            kwargs (dict): optional args for the tokenizer `train`\n        \"\"\"\n        if isinstance(files, str):\n            files = [files]\n        self.tokenizer.train(files=files, trainer=self.trainer)\n\n    def __getstate__(self):\n        \"\"\"Getting state to allow pickling\"\"\"\n        with attr_as(self.tokenizer, \"pre_tokenizer\", Whitespace()):\n            d = copy.deepcopy(self.__dict__)\n        # copy back tokenizer level attribute\n        d[\"tokenizer_attrs\"] = self.tokenizer.__dict__.copy()\n        d[\"tokenizer\"].pre_tokenizer = Whitespace()\n        return d\n\n    def __setstate__(self, d):\n        \"\"\"Setting state during reloading pickling\"\"\"\n        use_pretokenizer = d.get(\"custom_pre_tokenizer\")\n        if use_pretokenizer:\n            d[\"tokenizer\"].pre_tokenizer = PreTokenizer.custom(SAFESplitter())\n        d[\"tokenizer\"].__dict__.update(d.get(\"tokenizer_attrs\", {}))\n        self.__dict__.update(d)\n\n    def train_from_iterator(self, data: Iterator, **kwargs: Any):\n        \"\"\"Train the Tokenizer using the provided iterator.\n\n        You can provide anything that is a Python Iterator\n            * A list of sequences :obj:`List[str]`\n            * A generator that yields :obj:`str` or :obj:`List[str]`\n            * A Numpy array of strings\n\n        Args:\n            data: data iterator\n            **kwargs: additional keyword argument for the tokenizer `train_from_iterator`\n        \"\"\"\n        self.tokenizer.train_from_iterator(data, trainer=self.trainer, **kwargs)\n\n    def __len__(self):\n        r\"\"\"\n        Returns: Gets the count of tokens in vocab along with special tokens.\n\n        \"\"\"\n        return len(self.tokenizer.get_vocab().keys())\n\n    def encode(self, sample_str: str, ids_only: bool = True, **kwargs) -&gt; list:\n        r\"\"\"\n        Encodes a given molecule string once training is done\n\n        Args:\n            sample_str: Sample string to encode molecule\n            ids_only: whether to return only the ids or the encoding objet\n\n        Returns:\n            object: Returns encoded list of IDs\n        \"\"\"\n        if isinstance(sample_str, str):\n            enc = self.tokenizer.encode(sample_str, **kwargs)\n            if ids_only:\n                return enc.ids\n            return enc\n\n        encs = self.tokenizer.encode_batch(sample_str, **kwargs)\n        if ids_only:\n            return [enc.ids for enc in encs]\n        return encs\n\n    def to_dict(self, **kwargs):\n        \"\"\"Convert tokenizer to dict\"\"\"\n        # we need to do this because HuggingFace tokenizers doesnt save with custom pre-tokenizers\n        if self.splitter is None:\n            tk_data = json.loads(self.tokenizer.to_str())\n        else:\n            with attr_as(self.tokenizer, \"pre_tokenizer\", Whitespace()):\n                # temporary replace pre tokenizer with whitespace\n                tk_data = json.loads(self.tokenizer.to_str())\n                tk_data[\"custom_pre_tokenizer\"] = True\n        tk_data[\"tokenizer_type\"] = self.tokenizer_type\n        tk_data[\"tokenizer_attrs\"] = self.tokenizer.__dict__\n        return tk_data\n\n    def save_pretrained(self, *args, **kwargs):\n        \"\"\"Save pretrained tokenizer\"\"\"\n        self.tokenizer.save_pretrained(*args, **kwargs)\n\n    def save(self, file_name=None):\n        r\"\"\"\n        Saves the :class:`~tokenizers.Tokenizer` to the file at the given path.\n\n        Args:\n            file_name (str, optional): File where to save tokenizer\n        \"\"\"\n        # EN: whole logic here assumes noone is going to mess with the special token\n        tk_data = self.to_dict()\n        with fsspec.open(file_name, \"w\", encoding=\"utf-8\") as OUT:\n            out_str = json.dumps(tk_data, ensure_ascii=False)\n            OUT.write(out_str)\n\n    @classmethod\n    def from_dict(cls, data: dict):\n        \"\"\"Load tokenizer from dict\n\n        Args:\n            data: dictionary containing the tokenizer info\n        \"\"\"\n        tokenizer_type = data.pop(\"tokenizer_type\", \"smiles\")\n        tokenizer_attrs = data.pop(\"tokenizer_attrs\", None)\n        custom_pre_tokenizer = data.pop(\"custom_pre_tokenizer\", False)\n        tokenizer = Tokenizer.from_str(json.dumps(data))\n        if custom_pre_tokenizer:\n            tokenizer.pre_tokenizer = PreTokenizer.custom(SAFESplitter())\n        mol_tokenizer = cls(tokenizer_type)\n        mol_tokenizer.tokenizer = mol_tokenizer.set_special_tokens(tokenizer)\n        if tokenizer_attrs and isinstance(tokenizer_attrs, dict):\n            mol_tokenizer.tokenizer.__dict__.update(tokenizer_attrs)\n        return mol_tokenizer\n\n    @classmethod\n    def load(cls, file_name):\n        \"\"\"Load the current tokenizer from file\"\"\"\n        with fsspec.open(file_name, \"r\") as OUT:\n            data_str = OUT.read()\n        data = json.loads(data_str)\n        # EN: the rust json parser of tokenizers has a predefined structure\n        # the next two lines are important\n        return cls.from_dict(data)\n\n    def decode(\n        self,\n        ids: list,\n        skip_special_tokens: bool = True,\n        ignore_stops: bool = False,\n        stop_token_ids: Optional[List[int]] = None,\n    ) -&gt; str:\n        r\"\"\"\n        Decodes a list of ids to molecular representation in the format in which this tokenizer was created.\n\n        Args:\n            ids: list of IDs\n            skip_special_tokens: whether to skip all special tokens when encountering them\n            ignore_stops: whether to ignore the stop tokens, thus decoding till the end\n            stop_token_ids: optional list of stop token ids to use\n\n        Returns:\n            sequence: str representation of molecule\n        \"\"\"\n        old_id_list = ids\n        if not isinstance(ids[0], (list, np.ndarray)) and not torch.is_tensor(ids[0]):\n            old_id_list = [ids]\n        if not stop_token_ids:\n            stop_token_ids = [self.tokenizer.token_to_id(self.tokenizer.eos_token)]\n\n        new_ids_list = []\n        for ids in old_id_list:\n            new_ids = ids\n            if not ignore_stops:\n                new_ids = []\n                # if first tokens are stop, we just remove it\n                # this is because of bart essentially\n                pos = 0\n                if len(ids) &gt; 1:\n                    while ids[pos] in stop_token_ids:\n                        pos += 1\n                # we only ignore when there is a list of tokens\n                ids = ids[pos:]\n                for pos, id in enumerate(ids):\n                    if int(id) in stop_token_ids:\n                        break\n                    new_ids.append(id)\n            new_ids_list.append(new_ids)\n        if len(new_ids_list) == 1:\n            return self.tokenizer.decode(\n                list(new_ids_list[0]), skip_special_tokens=skip_special_tokens\n            )\n        return self.tokenizer.decode_batch(\n            list(new_ids_list), skip_special_tokens=skip_special_tokens\n        )\n\n    def get_pretrained(self, **kwargs) -&gt; PreTrainedTokenizerFast:\n        r\"\"\"\n        Get a pretrained tokenizer from this tokenizer\n\n        Returns:\n            Returns pre-trained fast tokenizer for hugging face models.\n        \"\"\"\n        with attr_as(self.tokenizer, \"pre_tokenizer\", Whitespace()):\n            tk = PreTrainedTokenizerFast(tokenizer_object=self.tokenizer)\n        tk._tokenizer.pre_tokenizer = self.tokenizer.pre_tokenizer\n        # now we need to add special_tokens\n        tk.add_special_tokens(\n            {\n                \"cls_token\": self.tokenizer.cls_token,\n                \"bos_token\": self.tokenizer.bos_token,\n                \"eos_token\": self.tokenizer.eos_token,\n                \"mask_token\": self.tokenizer.mask_token,\n                \"pad_token\": self.tokenizer.pad_token,\n                \"unk_token\": self.tokenizer.unk_token,\n                \"sep_token\": self.tokenizer.sep_token,\n            }\n        )\n        if (\n            tk.model_max_length is None\n            or tk.model_max_length &gt; 1e8\n            and hasattr(self.tokenizer, \"model_max_length\")\n        ):\n            tk.model_max_length = self.tokenizer.model_max_length\n            setattr(\n                tk,\n                \"model_max_length\",\n                getattr(self.tokenizer, \"model_max_length\"),\n            )\n        return tk\n</code></pre>"},{"location":"api/safe.html#safe.tokenizer.SAFETokenizer.bos_token_id","title":"<code>bos_token_id</code>  <code>property</code>","text":"<p>Get the bos token id</p>"},{"location":"api/safe.html#safe.tokenizer.SAFETokenizer.eos_token_id","title":"<code>eos_token_id</code>  <code>property</code>","text":"<p>Get the bos token id</p>"},{"location":"api/safe.html#safe.tokenizer.SAFETokenizer.pad_token_id","title":"<code>pad_token_id</code>  <code>property</code>","text":"<p>Get the bos token id</p>"},{"location":"api/safe.html#safe.tokenizer.SAFETokenizer.__getstate__","title":"<code>__getstate__()</code>","text":"<p>Getting state to allow pickling</p> Source code in <code>safe/tokenizer.py</code> <pre><code>def __getstate__(self):\n    \"\"\"Getting state to allow pickling\"\"\"\n    with attr_as(self.tokenizer, \"pre_tokenizer\", Whitespace()):\n        d = copy.deepcopy(self.__dict__)\n    # copy back tokenizer level attribute\n    d[\"tokenizer_attrs\"] = self.tokenizer.__dict__.copy()\n    d[\"tokenizer\"].pre_tokenizer = Whitespace()\n    return d\n</code></pre>"},{"location":"api/safe.html#safe.tokenizer.SAFETokenizer.__len__","title":"<code>__len__()</code>","text":"<p>Returns: Gets the count of tokens in vocab along with special tokens.</p> Source code in <code>safe/tokenizer.py</code> <pre><code>def __len__(self):\n    r\"\"\"\n    Returns: Gets the count of tokens in vocab along with special tokens.\n\n    \"\"\"\n    return len(self.tokenizer.get_vocab().keys())\n</code></pre>"},{"location":"api/safe.html#safe.tokenizer.SAFETokenizer.__setstate__","title":"<code>__setstate__(d)</code>","text":"<p>Setting state during reloading pickling</p> Source code in <code>safe/tokenizer.py</code> <pre><code>def __setstate__(self, d):\n    \"\"\"Setting state during reloading pickling\"\"\"\n    use_pretokenizer = d.get(\"custom_pre_tokenizer\")\n    if use_pretokenizer:\n        d[\"tokenizer\"].pre_tokenizer = PreTokenizer.custom(SAFESplitter())\n    d[\"tokenizer\"].__dict__.update(d.get(\"tokenizer_attrs\", {}))\n    self.__dict__.update(d)\n</code></pre>"},{"location":"api/safe.html#safe.tokenizer.SAFETokenizer.decode","title":"<code>decode(ids, skip_special_tokens=True, ignore_stops=False, stop_token_ids=None)</code>","text":"<p>Decodes a list of ids to molecular representation in the format in which this tokenizer was created.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>list</code> <p>list of IDs</p> required <code>skip_special_tokens</code> <code>bool</code> <p>whether to skip all special tokens when encountering them</p> <code>True</code> <code>ignore_stops</code> <code>bool</code> <p>whether to ignore the stop tokens, thus decoding till the end</p> <code>False</code> <code>stop_token_ids</code> <code>Optional[List[int]]</code> <p>optional list of stop token ids to use</p> <code>None</code> <p>Returns:</p> Name Type Description <code>sequence</code> <code>str</code> <p>str representation of molecule</p> Source code in <code>safe/tokenizer.py</code> <pre><code>def decode(\n    self,\n    ids: list,\n    skip_special_tokens: bool = True,\n    ignore_stops: bool = False,\n    stop_token_ids: Optional[List[int]] = None,\n) -&gt; str:\n    r\"\"\"\n    Decodes a list of ids to molecular representation in the format in which this tokenizer was created.\n\n    Args:\n        ids: list of IDs\n        skip_special_tokens: whether to skip all special tokens when encountering them\n        ignore_stops: whether to ignore the stop tokens, thus decoding till the end\n        stop_token_ids: optional list of stop token ids to use\n\n    Returns:\n        sequence: str representation of molecule\n    \"\"\"\n    old_id_list = ids\n    if not isinstance(ids[0], (list, np.ndarray)) and not torch.is_tensor(ids[0]):\n        old_id_list = [ids]\n    if not stop_token_ids:\n        stop_token_ids = [self.tokenizer.token_to_id(self.tokenizer.eos_token)]\n\n    new_ids_list = []\n    for ids in old_id_list:\n        new_ids = ids\n        if not ignore_stops:\n            new_ids = []\n            # if first tokens are stop, we just remove it\n            # this is because of bart essentially\n            pos = 0\n            if len(ids) &gt; 1:\n                while ids[pos] in stop_token_ids:\n                    pos += 1\n            # we only ignore when there is a list of tokens\n            ids = ids[pos:]\n            for pos, id in enumerate(ids):\n                if int(id) in stop_token_ids:\n                    break\n                new_ids.append(id)\n        new_ids_list.append(new_ids)\n    if len(new_ids_list) == 1:\n        return self.tokenizer.decode(\n            list(new_ids_list[0]), skip_special_tokens=skip_special_tokens\n        )\n    return self.tokenizer.decode_batch(\n        list(new_ids_list), skip_special_tokens=skip_special_tokens\n    )\n</code></pre>"},{"location":"api/safe.html#safe.tokenizer.SAFETokenizer.encode","title":"<code>encode(sample_str, ids_only=True, **kwargs)</code>","text":"<p>Encodes a given molecule string once training is done</p> <p>Parameters:</p> Name Type Description Default <code>sample_str</code> <code>str</code> <p>Sample string to encode molecule</p> required <code>ids_only</code> <code>bool</code> <p>whether to return only the ids or the encoding objet</p> <code>True</code> <p>Returns:</p> Name Type Description <code>object</code> <code>list</code> <p>Returns encoded list of IDs</p> Source code in <code>safe/tokenizer.py</code> <pre><code>def encode(self, sample_str: str, ids_only: bool = True, **kwargs) -&gt; list:\n    r\"\"\"\n    Encodes a given molecule string once training is done\n\n    Args:\n        sample_str: Sample string to encode molecule\n        ids_only: whether to return only the ids or the encoding objet\n\n    Returns:\n        object: Returns encoded list of IDs\n    \"\"\"\n    if isinstance(sample_str, str):\n        enc = self.tokenizer.encode(sample_str, **kwargs)\n        if ids_only:\n            return enc.ids\n        return enc\n\n    encs = self.tokenizer.encode_batch(sample_str, **kwargs)\n    if ids_only:\n        return [enc.ids for enc in encs]\n    return encs\n</code></pre>"},{"location":"api/safe.html#safe.tokenizer.SAFETokenizer.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Load tokenizer from dict</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>dictionary containing the tokenizer info</p> required Source code in <code>safe/tokenizer.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict):\n    \"\"\"Load tokenizer from dict\n\n    Args:\n        data: dictionary containing the tokenizer info\n    \"\"\"\n    tokenizer_type = data.pop(\"tokenizer_type\", \"smiles\")\n    tokenizer_attrs = data.pop(\"tokenizer_attrs\", None)\n    custom_pre_tokenizer = data.pop(\"custom_pre_tokenizer\", False)\n    tokenizer = Tokenizer.from_str(json.dumps(data))\n    if custom_pre_tokenizer:\n        tokenizer.pre_tokenizer = PreTokenizer.custom(SAFESplitter())\n    mol_tokenizer = cls(tokenizer_type)\n    mol_tokenizer.tokenizer = mol_tokenizer.set_special_tokens(tokenizer)\n    if tokenizer_attrs and isinstance(tokenizer_attrs, dict):\n        mol_tokenizer.tokenizer.__dict__.update(tokenizer_attrs)\n    return mol_tokenizer\n</code></pre>"},{"location":"api/safe.html#safe.tokenizer.SAFETokenizer.get_pretrained","title":"<code>get_pretrained(**kwargs)</code>","text":"<p>Get a pretrained tokenizer from this tokenizer</p> <p>Returns:</p> Type Description <code>PreTrainedTokenizerFast</code> <p>Returns pre-trained fast tokenizer for hugging face models.</p> Source code in <code>safe/tokenizer.py</code> <pre><code>def get_pretrained(self, **kwargs) -&gt; PreTrainedTokenizerFast:\n    r\"\"\"\n    Get a pretrained tokenizer from this tokenizer\n\n    Returns:\n        Returns pre-trained fast tokenizer for hugging face models.\n    \"\"\"\n    with attr_as(self.tokenizer, \"pre_tokenizer\", Whitespace()):\n        tk = PreTrainedTokenizerFast(tokenizer_object=self.tokenizer)\n    tk._tokenizer.pre_tokenizer = self.tokenizer.pre_tokenizer\n    # now we need to add special_tokens\n    tk.add_special_tokens(\n        {\n            \"cls_token\": self.tokenizer.cls_token,\n            \"bos_token\": self.tokenizer.bos_token,\n            \"eos_token\": self.tokenizer.eos_token,\n            \"mask_token\": self.tokenizer.mask_token,\n            \"pad_token\": self.tokenizer.pad_token,\n            \"unk_token\": self.tokenizer.unk_token,\n            \"sep_token\": self.tokenizer.sep_token,\n        }\n    )\n    if (\n        tk.model_max_length is None\n        or tk.model_max_length &gt; 1e8\n        and hasattr(self.tokenizer, \"model_max_length\")\n    ):\n        tk.model_max_length = self.tokenizer.model_max_length\n        setattr(\n            tk,\n            \"model_max_length\",\n            getattr(self.tokenizer, \"model_max_length\"),\n        )\n    return tk\n</code></pre>"},{"location":"api/safe.html#safe.tokenizer.SAFETokenizer.load","title":"<code>load(file_name)</code>  <code>classmethod</code>","text":"<p>Load the current tokenizer from file</p> Source code in <code>safe/tokenizer.py</code> <pre><code>@classmethod\ndef load(cls, file_name):\n    \"\"\"Load the current tokenizer from file\"\"\"\n    with fsspec.open(file_name, \"r\") as OUT:\n        data_str = OUT.read()\n    data = json.loads(data_str)\n    # EN: the rust json parser of tokenizers has a predefined structure\n    # the next two lines are important\n    return cls.from_dict(data)\n</code></pre>"},{"location":"api/safe.html#safe.tokenizer.SAFETokenizer.save","title":"<code>save(file_name=None)</code>","text":"<p>Saves the :class:<code>~tokenizers.Tokenizer</code> to the file at the given path.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>File where to save tokenizer</p> <code>None</code> Source code in <code>safe/tokenizer.py</code> <pre><code>def save(self, file_name=None):\n    r\"\"\"\n    Saves the :class:`~tokenizers.Tokenizer` to the file at the given path.\n\n    Args:\n        file_name (str, optional): File where to save tokenizer\n    \"\"\"\n    # EN: whole logic here assumes noone is going to mess with the special token\n    tk_data = self.to_dict()\n    with fsspec.open(file_name, \"w\", encoding=\"utf-8\") as OUT:\n        out_str = json.dumps(tk_data, ensure_ascii=False)\n        OUT.write(out_str)\n</code></pre>"},{"location":"api/safe.html#safe.tokenizer.SAFETokenizer.save_pretrained","title":"<code>save_pretrained(*args, **kwargs)</code>","text":"<p>Save pretrained tokenizer</p> Source code in <code>safe/tokenizer.py</code> <pre><code>def save_pretrained(self, *args, **kwargs):\n    \"\"\"Save pretrained tokenizer\"\"\"\n    self.tokenizer.save_pretrained(*args, **kwargs)\n</code></pre>"},{"location":"api/safe.html#safe.tokenizer.SAFETokenizer.set_special_tokens","title":"<code>set_special_tokens(tokenizer, bos_token=CLS_TOKEN, eos_token=SEP_TOKEN)</code>  <code>classmethod</code>","text":"<p>Set special tokens for a tokenizer</p> <p>Parameters:</p> Name Type Description Default <code>tokenizer</code> <code>Tokenizer</code> <p>tokenizer for which special tokens will be set</p> required <code>bos_token</code> <code>str</code> <p>Optional bos token to use</p> <code>CLS_TOKEN</code> <code>eos_token</code> <code>str</code> <p>Optional eos token to use</p> <code>SEP_TOKEN</code> Source code in <code>safe/tokenizer.py</code> <pre><code>@classmethod\ndef set_special_tokens(\n    cls,\n    tokenizer: Tokenizer,\n    bos_token: str = CLS_TOKEN,\n    eos_token: str = SEP_TOKEN,\n):\n    \"\"\"Set special tokens for a tokenizer\n\n    Args:\n        tokenizer: tokenizer for which special tokens will be set\n        bos_token: Optional bos token to use\n        eos_token: Optional eos token to use\n    \"\"\"\n    tokenizer.pad_token = PADDING_TOKEN\n    tokenizer.cls_token = CLS_TOKEN\n    tokenizer.sep_token = SEP_TOKEN\n    tokenizer.mask_token = MASK_TOKEN\n    tokenizer.unk_token = UNK_TOKEN\n    tokenizer.eos_token = eos_token\n    tokenizer.bos_token = bos_token\n\n    if isinstance(tokenizer, Tokenizer):\n        tokenizer.add_special_tokens(\n            [\n                PADDING_TOKEN,\n                CLS_TOKEN,\n                SEP_TOKEN,\n                MASK_TOKEN,\n                UNK_TOKEN,\n                eos_token,\n                bos_token,\n            ]\n        )\n    return tokenizer\n</code></pre>"},{"location":"api/safe.html#safe.tokenizer.SAFETokenizer.to_dict","title":"<code>to_dict(**kwargs)</code>","text":"<p>Convert tokenizer to dict</p> Source code in <code>safe/tokenizer.py</code> <pre><code>def to_dict(self, **kwargs):\n    \"\"\"Convert tokenizer to dict\"\"\"\n    # we need to do this because HuggingFace tokenizers doesnt save with custom pre-tokenizers\n    if self.splitter is None:\n        tk_data = json.loads(self.tokenizer.to_str())\n    else:\n        with attr_as(self.tokenizer, \"pre_tokenizer\", Whitespace()):\n            # temporary replace pre tokenizer with whitespace\n            tk_data = json.loads(self.tokenizer.to_str())\n            tk_data[\"custom_pre_tokenizer\"] = True\n    tk_data[\"tokenizer_type\"] = self.tokenizer_type\n    tk_data[\"tokenizer_attrs\"] = self.tokenizer.__dict__\n    return tk_data\n</code></pre>"},{"location":"api/safe.html#safe.tokenizer.SAFETokenizer.train","title":"<code>train(files, **kwargs)</code>","text":"<p>This is to train a new tokenizer from either a list of file or some input data</p> <p>Args     files (str): file in which your molecules are separated by new line     kwargs (dict): optional args for the tokenizer <code>train</code></p> Source code in <code>safe/tokenizer.py</code> <pre><code>def train(self, files: Optional[List[str]], **kwargs):\n    r\"\"\"\n    This is to train a new tokenizer from either a list of file or some input data\n\n    Args\n        files (str): file in which your molecules are separated by new line\n        kwargs (dict): optional args for the tokenizer `train`\n    \"\"\"\n    if isinstance(files, str):\n        files = [files]\n    self.tokenizer.train(files=files, trainer=self.trainer)\n</code></pre>"},{"location":"api/safe.html#safe.tokenizer.SAFETokenizer.train_from_iterator","title":"<code>train_from_iterator(data, **kwargs)</code>","text":"<p>Train the Tokenizer using the provided iterator.</p> <p>You can provide anything that is a Python Iterator     * A list of sequences :obj:<code>List[str]</code>     * A generator that yields :obj:<code>str</code> or :obj:<code>List[str]</code>     * A Numpy array of strings</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Iterator</code> <p>data iterator</p> required <code>**kwargs</code> <code>Any</code> <p>additional keyword argument for the tokenizer <code>train_from_iterator</code></p> <code>{}</code> Source code in <code>safe/tokenizer.py</code> <pre><code>def train_from_iterator(self, data: Iterator, **kwargs: Any):\n    \"\"\"Train the Tokenizer using the provided iterator.\n\n    You can provide anything that is a Python Iterator\n        * A list of sequences :obj:`List[str]`\n        * A generator that yields :obj:`str` or :obj:`List[str]`\n        * A Numpy array of strings\n\n    Args:\n        data: data iterator\n        **kwargs: additional keyword argument for the tokenizer `train_from_iterator`\n    \"\"\"\n    self.tokenizer.train_from_iterator(data, trainer=self.trainer, **kwargs)\n</code></pre>"},{"location":"api/safe.html#utils","title":"Utils","text":""},{"location":"api/safe.html#safe.utils.MolSlicer","title":"<code>MolSlicer</code>","text":"<p>Slice a molecule into head-linker-tail</p> Source code in <code>safe/utils.py</code> <pre><code>class MolSlicer:\n    \"\"\"Slice a molecule into head-linker-tail\"\"\"\n\n    BOND_SPLITTERS = [\n        # two atoms connected by a non ring single bond, one of each is not in a ring and at least two heavy neighbor\n        \"[R:1]-&amp;!@[!R;!D1:2]\",\n        # two atoms in different rings linked by a non-ring single bond\n        \"[R:1]-&amp;!@[R:2]\",\n    ]\n    _BOND_BUFFER = 1  # buffer around substructure match size.\n    MAX_CUTS = 2  # maximum number of cuts. Here we need two cuts for head-linker-tail.\n\n    _MERGING_RXN = dm.reactions.rxn_from_smarts(\n        \"[#0][*:1].[#0][*:4].([#0][*:2].[#0][*:3])&gt;&gt;([*:1][*:2].[*:3][*:4])\"\n    )\n\n    def __init__(\n        self,\n        shortest_linker: bool = False,\n        min_linker_size: int = 0,\n        require_ring_system: bool = True,\n        verbose: bool = False,\n    ):\n        \"\"\"\n        Constructor of bond slicer.\n\n        Args:\n            shortest_linker: whether to consider longuest or shortest linker.\n                Does not have any effect when expected_head group is provided during splitting\n            min_linker_size: minimum linker size\n            require_ring_system: whether all fragment needs to have a ring system\n            verbose: whether to allow verbosity in logging\n        \"\"\"\n\n        self.bond_splitters = [dm.from_smarts(x) for x in self.BOND_SPLITTERS]\n        self.shortest_linker = shortest_linker\n        self.min_linker_size = min_linker_size\n        self.require_ring_system = require_ring_system\n        self.verbose = verbose\n\n    def get_ring_system(self, mol: dm.Mol):\n        \"\"\"Get the list of ring system from a molecule\n\n        Args:\n            mol: input molecule for which we are computing the ring system\n        \"\"\"\n        mol.UpdatePropertyCache()\n        ri = mol.GetRingInfo()\n        systems = []\n        for ring in ri.AtomRings():\n            ring_atoms = set(ring)\n            cur_system = []  # keep a track of ring system\n            for system in systems:\n                if len(ring_atoms.intersection(system)) &gt; 0:\n                    ring_atoms = ring_atoms.union(system)  # merge ring system that overlap\n                else:\n                    cur_system.append(system)\n            cur_system.append(ring_atoms)\n            systems = cur_system\n        return systems\n\n    def _bond_selection_from_max_cuts(self, bond_list: List[int], dist_mat: np.ndarray):\n        \"\"\"Select bonds based on maximum number of cuts allowed\"\"\"\n        # for now we are just implementing to 2 max cuts algorithms\n        if self.MAX_CUTS != 2:\n            raise ValueError(f\"Only MAX_CUTS=2 is supported, got {self.MAX_CUTS}\")\n\n        bond_pdist = np.full((len(bond_list), len(bond_list)), -1)\n        for i in range(len(bond_list)):\n            for j in range(i, len(bond_list)):\n                # we get the minimum topological distance between bond to cut\n                bond_pdist[i, j] = bond_pdist[j, i] = min(\n                    [dist_mat[a1, a2] for a1, a2 in itertools.product(bond_list[i], bond_list[j])]\n                )\n\n        masked_bond_pdist = np.ma.masked_less_equal(bond_pdist, self.min_linker_size)\n\n        if self.shortest_linker:\n            return np.unravel_index(np.ma.argmin(masked_bond_pdist), bond_pdist.shape)\n        return np.unravel_index(np.ma.argmax(masked_bond_pdist), bond_pdist.shape)\n\n    def _get_bonds_to_cut(self, mol: dm.Mol):\n        \"\"\"Get possible bond to cuts\n\n        Args:\n            mol: input molecule\n        \"\"\"\n        # use this if you want to enumerate yourself the possible cuts\n\n        ring_systems = self.get_ring_system(mol)\n        candidate_bonds = []\n        ring_query = Chem.rdqueries.IsInRingQueryAtom()\n\n        for query in self.bond_splitters:\n            bonds = mol.GetSubstructMatches(query, uniquify=True)\n            cur_unique_bonds = [set(cbond) for cbond in candidate_bonds]\n            # do not accept bonds part of the same ring system or already known\n            for b in bonds:\n                bond_id = mol.GetBondBetweenAtoms(*b).GetIdx()\n                bond_cut = Chem.GetMolFrags(\n                    Chem.FragmentOnBonds(mol, [bond_id], addDummies=False), asMols=True\n                )\n                can_add = not self.require_ring_system or all(\n                    len(frag.GetAtomsMatchingQuery(ring_query)) &gt; 0 for frag in bond_cut\n                )\n                if can_add and not (\n                    set(b) in cur_unique_bonds or any(x.issuperset(set(b)) for x in ring_systems)\n                ):\n                    candidate_bonds.append(b)\n        return candidate_bonds\n\n    def _fragment_mol(self, mol: dm.Mol, bonds: List[dm.Bond]):\n        \"\"\"Fragment molecules on bonds and return head, linker, tail combination\n\n        Args:\n            mol: input molecule\n            bonds: list of bonds to cut\n        \"\"\"\n        tmp = Chem.rdmolops.FragmentOnBonds(mol, [b.GetIdx() for b in bonds])\n        _frags = list(Chem.GetMolFrags(tmp, asMols=True))\n        # linker is the one with 2 dummy atoms\n        linker_pos = 0\n        for pos, _frag in enumerate(_frags):\n            if sum([at.GetSymbol() == \"*\" for at in _frag.GetAtoms()]) == 2:\n                linker_pos = pos\n                break\n        linker = _frags.pop(linker_pos)\n        head, tail = _frags\n        return (head, linker, tail)\n\n    def _compute_linker_score(self, linker: dm.Mol):\n        \"\"\"Compute the score of a linker to help select between linkers\"\"\"\n\n        # we need to take into account\n        # case where we require the linker to have a ring system\n        # case where we want the linker to be longuest or shortest\n\n        # find shortest path\n        attach1, attach2, *_ = [at.GetIdx() for at in linker.GetAtoms() if at.GetSymbol() == \"*\"]\n        score = len(Chem.rdmolops.GetShortestPath(linker, attach1, attach2))\n        ring_query = Chem.rdqueries.IsInRingQueryAtom()\n        linker_ring_count = len(linker.GetAtomsMatchingQuery(ring_query))\n        if self.require_ring_system:\n            score *= int(linker_ring_count &gt; 0)\n        if score == 0:\n            return float(\"inf\")\n        if not self.shortest_linker:\n            score = 1 / score\n        return score\n\n    def __call__(self, mol: Union[dm.Mol, str], expected_head: Union[dm.Mol, str] = None):\n        \"\"\"Perform slicing of the input molecule\n\n        Args:\n            mol: input molecule\n            expected_head: substructure that should be part of the head.\n                The small fragment containing this substructure would be kept as head\n        \"\"\"\n\n        mol = dm.to_mol(mol)\n        # remove salt and solution\n        mol = dm.keep_largest_fragment(mol)\n        Chem.rdDepictor.Compute2DCoords(mol)\n        dist_mat = Chem.rdmolops.GetDistanceMatrix(mol)\n\n        if expected_head is not None:\n            if isinstance(expected_head, str):\n                expected_head = dm.to_mol(expected_head)\n            if not mol.HasSubstructMatch(expected_head):\n                if self.verbose:\n                    logger.info(\n                        \"Expected head was provided, but does not match molecules. It will be ignored\"\n                    )\n                expected_head = None\n\n        candidate_bonds = self._get_bonds_to_cut(mol)\n\n        # we have all the candidate bonds we can cut\n        # now we need to pick the most plausible bonds\n        selected_bonds = [mol.GetBondBetweenAtoms(a1, a2) for (a1, a2) in candidate_bonds]\n\n        # CASE 1: no bond to cut ==&gt; only head\n        if len(selected_bonds) == 0:\n            return (mol, None, None)\n\n        # CASE 2: only one bond ==&gt; linker is empty\n        if len(selected_bonds) == 1:\n            # there is not linker\n            tmp = Chem.rdmolops.FragmentOnBonds(mol, [b.GetIdx() for b in selected_bonds])\n            head, tail = Chem.GetMolFrags(tmp, asMols=True)\n            return (head, None, tail)\n\n        # CASE 3a: we select the most plausible bond to cut on ourselves\n        if expected_head is None:\n            choice = self._bond_selection_from_max_cuts(candidate_bonds, dist_mat)\n            selected_bonds = [selected_bonds[c] for c in choice]\n            return self._fragment_mol(mol, selected_bonds)\n\n        # CASE 3b: slightly more complex case where we want the head to be the smallest graph containing the\n        # provided substructure\n        bond_combination = list(itertools.combinations(selected_bonds, self.MAX_CUTS))\n        bond_score = float(\"inf\")\n        linker_score = float(\"inf\")\n        head, linker, tail = (None, None, None)\n        for split_bonds in bond_combination:\n            cur_head, cur_linker, cur_tail = self._fragment_mol(mol, split_bonds)\n            # head can also be tail\n            head_match = cur_head.GetSubstructMatch(expected_head)\n            tail_match = cur_tail.GetSubstructMatch(expected_head)\n            if not head_match and not tail_match:\n                continue\n            if not head_match and tail_match:\n                cur_head, cur_tail = cur_tail, cur_head\n            cur_bond_score = cur_head.GetNumHeavyAtoms()\n            # compute linker score\n            cur_linker_score = self._compute_linker_score(cur_linker)\n            if (cur_bond_score &lt; bond_score) or (\n                cur_bond_score &lt; self._BOND_BUFFER + bond_score and cur_linker_score &lt; linker_score\n            ):\n                head, linker, tail = cur_head, cur_linker, cur_tail\n                bond_score = cur_bond_score\n                linker_score = cur_linker_score\n\n        return (head, linker, tail)\n\n    @classmethod\n    def link_fragments(\n        cls, linker: Union[dm.Mol, str], head: Union[dm.Mol, str], tail: Union[dm.Mol, str]\n    ):\n        \"\"\"Link fragments together using the provided linker\n\n        Args:\n            linker: linker to use\n            head: head fragment\n            tail: tail fragment\n        \"\"\"\n        if isinstance(linker, dm.Mol):\n            linker = dm.to_smiles(linker)\n        linker = standardize_attach(linker)\n        reactants = [dm.to_mol(head), dm.to_mol(tail), dm.to_mol(linker)]\n        return dm.reactions.apply_reaction(\n            cls._MERGING_RXN, reactants, as_smiles=True, sanitize=True, product_index=0\n        )\n</code></pre>"},{"location":"api/safe.html#safe.utils.MolSlicer.__call__","title":"<code>__call__(mol, expected_head=None)</code>","text":"<p>Perform slicing of the input molecule</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Union[Mol, str]</code> <p>input molecule</p> required <code>expected_head</code> <code>Union[Mol, str]</code> <p>substructure that should be part of the head. The small fragment containing this substructure would be kept as head</p> <code>None</code> Source code in <code>safe/utils.py</code> <pre><code>def __call__(self, mol: Union[dm.Mol, str], expected_head: Union[dm.Mol, str] = None):\n    \"\"\"Perform slicing of the input molecule\n\n    Args:\n        mol: input molecule\n        expected_head: substructure that should be part of the head.\n            The small fragment containing this substructure would be kept as head\n    \"\"\"\n\n    mol = dm.to_mol(mol)\n    # remove salt and solution\n    mol = dm.keep_largest_fragment(mol)\n    Chem.rdDepictor.Compute2DCoords(mol)\n    dist_mat = Chem.rdmolops.GetDistanceMatrix(mol)\n\n    if expected_head is not None:\n        if isinstance(expected_head, str):\n            expected_head = dm.to_mol(expected_head)\n        if not mol.HasSubstructMatch(expected_head):\n            if self.verbose:\n                logger.info(\n                    \"Expected head was provided, but does not match molecules. It will be ignored\"\n                )\n            expected_head = None\n\n    candidate_bonds = self._get_bonds_to_cut(mol)\n\n    # we have all the candidate bonds we can cut\n    # now we need to pick the most plausible bonds\n    selected_bonds = [mol.GetBondBetweenAtoms(a1, a2) for (a1, a2) in candidate_bonds]\n\n    # CASE 1: no bond to cut ==&gt; only head\n    if len(selected_bonds) == 0:\n        return (mol, None, None)\n\n    # CASE 2: only one bond ==&gt; linker is empty\n    if len(selected_bonds) == 1:\n        # there is not linker\n        tmp = Chem.rdmolops.FragmentOnBonds(mol, [b.GetIdx() for b in selected_bonds])\n        head, tail = Chem.GetMolFrags(tmp, asMols=True)\n        return (head, None, tail)\n\n    # CASE 3a: we select the most plausible bond to cut on ourselves\n    if expected_head is None:\n        choice = self._bond_selection_from_max_cuts(candidate_bonds, dist_mat)\n        selected_bonds = [selected_bonds[c] for c in choice]\n        return self._fragment_mol(mol, selected_bonds)\n\n    # CASE 3b: slightly more complex case where we want the head to be the smallest graph containing the\n    # provided substructure\n    bond_combination = list(itertools.combinations(selected_bonds, self.MAX_CUTS))\n    bond_score = float(\"inf\")\n    linker_score = float(\"inf\")\n    head, linker, tail = (None, None, None)\n    for split_bonds in bond_combination:\n        cur_head, cur_linker, cur_tail = self._fragment_mol(mol, split_bonds)\n        # head can also be tail\n        head_match = cur_head.GetSubstructMatch(expected_head)\n        tail_match = cur_tail.GetSubstructMatch(expected_head)\n        if not head_match and not tail_match:\n            continue\n        if not head_match and tail_match:\n            cur_head, cur_tail = cur_tail, cur_head\n        cur_bond_score = cur_head.GetNumHeavyAtoms()\n        # compute linker score\n        cur_linker_score = self._compute_linker_score(cur_linker)\n        if (cur_bond_score &lt; bond_score) or (\n            cur_bond_score &lt; self._BOND_BUFFER + bond_score and cur_linker_score &lt; linker_score\n        ):\n            head, linker, tail = cur_head, cur_linker, cur_tail\n            bond_score = cur_bond_score\n            linker_score = cur_linker_score\n\n    return (head, linker, tail)\n</code></pre>"},{"location":"api/safe.html#safe.utils.MolSlicer.__init__","title":"<code>__init__(shortest_linker=False, min_linker_size=0, require_ring_system=True, verbose=False)</code>","text":"<p>Constructor of bond slicer.</p> <p>Parameters:</p> Name Type Description Default <code>shortest_linker</code> <code>bool</code> <p>whether to consider longuest or shortest linker. Does not have any effect when expected_head group is provided during splitting</p> <code>False</code> <code>min_linker_size</code> <code>int</code> <p>minimum linker size</p> <code>0</code> <code>require_ring_system</code> <code>bool</code> <p>whether all fragment needs to have a ring system</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>whether to allow verbosity in logging</p> <code>False</code> Source code in <code>safe/utils.py</code> <pre><code>def __init__(\n    self,\n    shortest_linker: bool = False,\n    min_linker_size: int = 0,\n    require_ring_system: bool = True,\n    verbose: bool = False,\n):\n    \"\"\"\n    Constructor of bond slicer.\n\n    Args:\n        shortest_linker: whether to consider longuest or shortest linker.\n            Does not have any effect when expected_head group is provided during splitting\n        min_linker_size: minimum linker size\n        require_ring_system: whether all fragment needs to have a ring system\n        verbose: whether to allow verbosity in logging\n    \"\"\"\n\n    self.bond_splitters = [dm.from_smarts(x) for x in self.BOND_SPLITTERS]\n    self.shortest_linker = shortest_linker\n    self.min_linker_size = min_linker_size\n    self.require_ring_system = require_ring_system\n    self.verbose = verbose\n</code></pre>"},{"location":"api/safe.html#safe.utils.MolSlicer.get_ring_system","title":"<code>get_ring_system(mol)</code>","text":"<p>Get the list of ring system from a molecule</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>input molecule for which we are computing the ring system</p> required Source code in <code>safe/utils.py</code> <pre><code>def get_ring_system(self, mol: dm.Mol):\n    \"\"\"Get the list of ring system from a molecule\n\n    Args:\n        mol: input molecule for which we are computing the ring system\n    \"\"\"\n    mol.UpdatePropertyCache()\n    ri = mol.GetRingInfo()\n    systems = []\n    for ring in ri.AtomRings():\n        ring_atoms = set(ring)\n        cur_system = []  # keep a track of ring system\n        for system in systems:\n            if len(ring_atoms.intersection(system)) &gt; 0:\n                ring_atoms = ring_atoms.union(system)  # merge ring system that overlap\n            else:\n                cur_system.append(system)\n        cur_system.append(ring_atoms)\n        systems = cur_system\n    return systems\n</code></pre>"},{"location":"api/safe.html#safe.utils.MolSlicer.link_fragments","title":"<code>link_fragments(linker, head, tail)</code>  <code>classmethod</code>","text":"<p>Link fragments together using the provided linker</p> <p>Parameters:</p> Name Type Description Default <code>linker</code> <code>Union[Mol, str]</code> <p>linker to use</p> required <code>head</code> <code>Union[Mol, str]</code> <p>head fragment</p> required <code>tail</code> <code>Union[Mol, str]</code> <p>tail fragment</p> required Source code in <code>safe/utils.py</code> <pre><code>@classmethod\ndef link_fragments(\n    cls, linker: Union[dm.Mol, str], head: Union[dm.Mol, str], tail: Union[dm.Mol, str]\n):\n    \"\"\"Link fragments together using the provided linker\n\n    Args:\n        linker: linker to use\n        head: head fragment\n        tail: tail fragment\n    \"\"\"\n    if isinstance(linker, dm.Mol):\n        linker = dm.to_smiles(linker)\n    linker = standardize_attach(linker)\n    reactants = [dm.to_mol(head), dm.to_mol(tail), dm.to_mol(linker)]\n    return dm.reactions.apply_reaction(\n        cls._MERGING_RXN, reactants, as_smiles=True, sanitize=True, product_index=0\n    )\n</code></pre>"},{"location":"api/safe.html#safe.utils.attr_as","title":"<code>attr_as(obj, field, value)</code>","text":"<p>Temporary replace the value of an object Args:     obj: object to temporary patch     field: name of the key to change     value: value of key to be temporary changed</p> Source code in <code>safe/utils.py</code> <pre><code>@contextmanager\ndef attr_as(obj, field, value):\n    \"\"\"Temporary replace the value of an object\n    Args:\n        obj: object to temporary patch\n        field: name of the key to change\n        value: value of key to be temporary changed\n    \"\"\"\n    old_value = getattr(obj, field, None)\n    setattr(obj, field, value)\n    yield\n    with suppress(TypeError):\n        setattr(obj, field, old_value)\n</code></pre>"},{"location":"api/safe.html#safe.utils.compute_side_chains","title":"<code>compute_side_chains(mol, core, label_by_index=False)</code>","text":"<p>Compute the side chain of a molecule given a core</p> <p>Finding the side chains</p> <p>The algorithm to find the side chains from core assumes that the core we get as input has attachment points. Those attachment points are never considered as part of the query, rather they are used to define the attachment points on the side chains. Removing the attachment points from the core is exactly the same as keeping them.</p> <p><pre><code>mol = \"CC1=C(C(=NO1)C2=CC=CC=C2Cl)C(=O)NC3C4N(C3=O)C(C(S4)(C)C)C(=O)O\"\ncore0 = \"CC1(C)CN2C(CC2=O)S1\"\ncore1 = \"CC1(C)SC2C(-*)C(=O)N2C1-*\"\ncore2 = \"CC1N2C(SC1(C)C)C(N)C2=O\"\nside_chain = compute_side_chain(core=core0, mol=mol)\ndm.to_image([side_chain, core0, mol])\n</code></pre> Therefore on the above, core0 and core1 are equivalent for the molecule <code>mol</code>, but core2 is not.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>molecule to split</p> required <code>core</code> <code>Mol</code> <p>core to use for deriving the side chains</p> required Source code in <code>safe/utils.py</code> <pre><code>def compute_side_chains(mol: dm.Mol, core: dm.Mol, label_by_index: bool = False):\n    \"\"\"Compute the side chain of a molecule given a core\n\n    !!! note \"Finding the side chains\"\n        The algorithm to find the side chains from core assumes that the core we get as input has attachment points.\n        Those attachment points are never considered as part of the query, rather they are used to define the attachment points\n        on the side chains. Removing the attachment points from the core is exactly the same as keeping them.\n\n        ```python\n        mol = \"CC1=C(C(=NO1)C2=CC=CC=C2Cl)C(=O)NC3C4N(C3=O)C(C(S4)(C)C)C(=O)O\"\n        core0 = \"CC1(C)CN2C(CC2=O)S1\"\n        core1 = \"CC1(C)SC2C(-*)C(=O)N2C1-*\"\n        core2 = \"CC1N2C(SC1(C)C)C(N)C2=O\"\n        side_chain = compute_side_chain(core=core0, mol=mol)\n        dm.to_image([side_chain, core0, mol])\n        ```\n        Therefore on the above, core0 and core1 are equivalent for the molecule `mol`, but core2 is not.\n\n    Args:\n        mol: molecule to split\n        core: core to use for deriving the side chains\n    \"\"\"\n\n    if isinstance(mol, str):\n        mol = dm.to_mol(mol)\n    if isinstance(core, str):\n        core = dm.to_mol(core)\n    core_query_param = AdjustQueryParameters()\n    core_query_param.makeDummiesQueries = True\n    core_query_param.adjustDegree = False\n    core_query_param.aromatizeIfPossible = True\n    core_query_param.makeBondsGeneric = False\n    core_query = AdjustQueryProperties(core, core_query_param)\n    return ReplaceCore(\n        mol, core_query, labelByIndex=label_by_index, replaceDummies=False, requireDummyMatch=False\n    )\n</code></pre>"},{"location":"api/safe.html#safe.utils.convert_to_safe","title":"<code>convert_to_safe(mol, canonical=False, randomize=False, seed=1, slicer='brics', split_fragment=True, fraction_hs=None, resolution=0.5)</code>","text":"<p>Convert a molecule to a safe representation</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>molecule to convert</p> required <code>canonical</code> <code>bool</code> <p>whether to use canonical encoding</p> <code>False</code> <code>randomize</code> <code>bool</code> <p>whether to randomize the encoding</p> <code>False</code> <code>seed</code> <code>Optional[int]</code> <p>random seed</p> <code>1</code> <code>slicer</code> <code>str</code> <p>the slicer to use for fragmentation</p> <code>'brics'</code> <code>split_fragment</code> <code>bool</code> <p>whether to split fragments</p> <code>True</code> <code>fraction_hs</code> <code>bool</code> <p>proportion of random atom to which we will add explicit hydrogens</p> <code>None</code> <code>resolution</code> <code>Optional[float]</code> <p>resolution for the partitioning algorithm</p> <code>0.5</code> <code>seed</code> <code>Optional[int]</code> <p>random seed</p> <code>1</code> Source code in <code>safe/utils.py</code> <pre><code>def convert_to_safe(\n    mol: dm.Mol,\n    canonical: bool = False,\n    randomize: bool = False,\n    seed: Optional[int] = 1,\n    slicer: str = \"brics\",\n    split_fragment: bool = True,\n    fraction_hs: bool = None,\n    resolution: Optional[float] = 0.5,\n):\n    \"\"\"Convert a molecule to a safe representation\n\n    Args:\n        mol: molecule to convert\n        canonical: whether to use canonical encoding\n        randomize: whether to randomize the encoding\n        seed: random seed\n        slicer: the slicer to use for fragmentation\n        split_fragment: whether to split fragments\n        fraction_hs: proportion of random atom to which we will add explicit hydrogens\n        resolution: resolution for the partitioning algorithm\n        seed: random seed\n    \"\"\"\n    x = None\n    try:\n        x = sf.encode(mol, canonical=canonical, randomize=randomize, slicer=slicer, seed=seed)\n    except sf.SAFEFragmentationError:\n        if split_fragment:\n            if \".\" in mol:\n                return None\n            try:\n                x = sf.encode(\n                    mol,\n                    canonical=False,\n                    randomize=randomize,\n                    seed=seed,\n                    slicer=partial(\n                        fragment_aware_spliting,\n                        fraction_hs=fraction_hs,\n                        resolution=resolution,\n                        seed=seed,\n                    ),\n                )\n            except (sf.SAFEEncodeError, sf.SAFEFragmentationError):\n                # logger.exception(e)\n                return x\n        # we need to resplit using attachment point but here we are only adding\n    except sf.SAFEEncodeError:\n        return x\n    return x\n</code></pre>"},{"location":"api/safe.html#safe.utils.filter_by_substructure_constraints","title":"<code>filter_by_substructure_constraints(sequences, substruct, n_jobs=-1)</code>","text":"<p>Check whether the input substructures are present in each of the molecule in the sequences</p> <p>Parameters:</p> Name Type Description Default <code>sequences</code> <code>List[Union[str, Mol]]</code> <p>list of molecules to validate</p> required <code>substruct</code> <code>Union[str, Mol]</code> <p>substructure to use as query</p> required <code>n_jobs</code> <code>int</code> <p>number of jobs to use for parallelization</p> <code>-1</code> Source code in <code>safe/utils.py</code> <pre><code>def filter_by_substructure_constraints(\n    sequences: List[Union[str, dm.Mol]], substruct: Union[str, dm.Mol], n_jobs: int = -1\n):\n    \"\"\"Check whether the input substructures are present in each of the molecule in the sequences\n\n    Args:\n        sequences: list of molecules to validate\n        substruct: substructure to use as query\n        n_jobs: number of jobs to use for parallelization\n\n    \"\"\"\n\n    if isinstance(substruct, str):\n        substruct = standardize_attach(substruct)\n        substruct = dm.from_smarts(substruct)\n\n    def _check_match(mol):\n        with suppress(Exception):\n            mol = dm.to_mol(mol)\n            return mol.HasSubstructMatch(substruct)\n        return False\n\n    matches = dm.parallelized(_check_match, sequences, n_jobs=n_jobs)\n    return list(compress(sequences, matches))\n</code></pre>"},{"location":"api/safe.html#safe.utils.find_partition_edges","title":"<code>find_partition_edges(G, partition)</code>","text":"<p>Find the edges connecting the subgraphs in a given partition of a graph.</p> <p>Parameters:</p> Name Type Description Default <code>G</code> <code>Graph</code> <p>The original graph.</p> required <code>partition</code> <code>list of list of nodes</code> <p>The partition of the graph where each element is a list of nodes representing a subgraph.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>List[Tuple]</code> <p>A list of edges connecting the subgraphs in the partition.</p> Source code in <code>safe/utils.py</code> <pre><code>def find_partition_edges(G: nx.Graph, partition: List[List]) -&gt; List[Tuple]:\n    \"\"\"\n    Find the edges connecting the subgraphs in a given partition of a graph.\n\n    Args:\n        G (networkx.Graph): The original graph.\n        partition (list of list of nodes): The partition of the graph where each element is a list of nodes representing a subgraph.\n\n    Returns:\n        list: A list of edges connecting the subgraphs in the partition.\n    \"\"\"\n    partition_edges = []\n    for subgraph1, subgraph2 in combinations(partition, 2):\n        edges = nx.edge_boundary(G, subgraph1, subgraph2)\n        partition_edges.extend(edges)\n    return partition_edges\n</code></pre>"},{"location":"api/safe.html#safe.utils.fragment_aware_spliting","title":"<code>fragment_aware_spliting(mol, fraction_hs=None, **kwargs)</code>","text":"<p>Custom splitting algorithm for dataset building.</p> <p>This slicing strategy will cut any bond including bonding with hydrogens However, only one cut per atom is allowed</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>molecule to split</p> required <code>fraction_hs</code> <code>Optional[bool]</code> <p>proportion of random atom to which we will add explicit hydrogens</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>additional arguments to pass to the partitioning algorithm</p> <code>{}</code> Source code in <code>safe/utils.py</code> <pre><code>def fragment_aware_spliting(mol: dm.Mol, fraction_hs: Optional[bool] = None, **kwargs: Any):\n    \"\"\"Custom splitting algorithm for dataset building.\n\n    This slicing strategy will cut any bond including bonding with hydrogens\n    However, only one cut per atom is allowed\n\n    Args:\n        mol: molecule to split\n        fraction_hs: proportion of random atom to which we will add explicit hydrogens\n        kwargs: additional arguments to pass to the partitioning algorithm\n    \"\"\"\n    random.seed(kwargs.get(\"seed\", 1))\n    mol = dm.to_mol(mol, remove_hs=False)\n    mol = _selective_add_hs(mol, fraction_hs=fraction_hs)\n    graph = dm.graph.to_graph(mol)\n    d = mol_partition(mol, **kwargs)\n    q = deque(d)\n    partition = q.pop()\n    return find_partition_edges(graph, partition)\n</code></pre>"},{"location":"api/safe.html#safe.utils.list_individual_attach_points","title":"<code>list_individual_attach_points(mol, depth=None)</code>","text":"<p>List all individual attachement points.</p> <p>We do not allow multiple attachment points per substitution position.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>molecule for which we need to open the attachment points</p> required Source code in <code>safe/utils.py</code> <pre><code>def list_individual_attach_points(mol: dm.Mol, depth: Optional[int] = None):\n    \"\"\"List all individual attachement points.\n\n    We do not allow multiple attachment points per substitution position.\n\n    Args:\n        mol: molecule for which we need to open the attachment points\n\n    \"\"\"\n    ATTACHING_RXN = ReactionFromSmarts(\"[*;h;!$([*][#0]):1]&gt;&gt;[*:1][*]\")\n    mols = [mol]\n    curated_prods = set()\n    num_attachs = len(mol.GetSubstructMatches(dm.from_smarts(\"[*;h:1]\"), uniquify=True))\n    depth = depth or 1\n    depth = min(max(depth, 1), num_attachs)\n    while depth &gt; 0:\n        prods = set()\n        for mol in mols:\n            mol = dm.to_mol(mol)\n            for p in ATTACHING_RXN.RunReactants((mol,)):\n                try:\n                    m = dm.sanitize_mol(p[0])\n                    sm = dm.to_smiles(m, canonical=True)\n                    sm = dm.reactions.add_brackets_to_attachment_points(sm)\n                    prods.add(dm.reactions.convert_attach_to_isotope(sm, as_smiles=True))\n                except Exception as e:\n                    logger.error(e)\n        curated_prods.update(prods)\n        mols = prods\n        depth -= 1\n    return list(curated_prods)\n</code></pre>"},{"location":"api/safe.html#safe.utils.mol_partition","title":"<code>mol_partition(mol, query=None, seed=None, **kwargs)</code>","text":"<p>Partition a molecule into fragments using a bond query</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Mol</code> <p>molecule to split</p> required <code>query</code> <code>Optional[Mol]</code> <p>bond query to use for splitting</p> <code>None</code> <code>seed</code> <code>Optional[int]</code> <p>random seed</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>additional arguments to pass to the partitioning algorithm</p> <code>{}</code> Source code in <code>safe/utils.py</code> <pre><code>@py_random_state(\"seed\")\ndef mol_partition(\n    mol: dm.Mol, query: Optional[dm.Mol] = None, seed: Optional[int] = None, **kwargs: Any\n):\n    \"\"\"Partition a molecule into fragments using a bond query\n\n    Args:\n        mol: molecule to split\n        query: bond query to use for splitting\n        seed: random seed\n        kwargs: additional arguments to pass to the partitioning algorithm\n\n    \"\"\"\n    resolution = kwargs.get(\"resolution\", 1.0)\n    threshold = kwargs.get(\"threshold\", 1e-7)\n    weight = kwargs.get(\"weight\", \"weight\")\n\n    if query is None:\n        query = __mmpa_query\n\n    G = dm.graph.to_graph(mol)\n    bond_partition = [\n        tuple(sorted(match)) for match in mol.GetSubstructMatches(query, uniquify=True)\n    ]\n\n    def get_relevant_edges(e1, e2):\n        return tuple(sorted([e1, e2])) not in bond_partition\n\n    subgraphs = nx.subgraph_view(G, filter_edge=get_relevant_edges)\n\n    partition = [{u} for u in G.nodes()]\n    inner_partition = sorted(nx.connected_components(subgraphs), key=lambda x: min(x))\n    mod = nx.algorithms.community.modularity(\n        G, inner_partition, resolution=resolution, weight=weight\n    )\n    is_directed = G.is_directed()\n    graph = G.__class__()\n    graph.add_nodes_from(G)\n    graph.add_weighted_edges_from(G.edges(data=weight, default=1))\n    graph = nx.algorithms.community.louvain._gen_graph(graph, inner_partition)\n    m = graph.size(weight=\"weight\")\n    partition, inner_partition, improvement = nx.algorithms.community.louvain._one_level(\n        graph, m, inner_partition, resolution, is_directed, seed\n    )\n    improvement = True\n    while improvement:\n        # gh-5901 protect the sets in the yielded list from further manipulation here\n        yield [s.copy() for s in partition]\n        new_mod = nx.algorithms.community.modularity(\n            graph, inner_partition, resolution=resolution, weight=\"weight\"\n        )\n        if new_mod - mod &lt;= threshold:\n            return\n        mod = new_mod\n        graph = nx.algorithms.community.louvain._gen_graph(graph, inner_partition)\n        partition, inner_partition, improvement = nx.algorithms.community.louvain._one_level(\n            graph, m, partition, resolution, is_directed, seed\n        )\n</code></pre>"},{"location":"api/safe.html#safe.utils.standardize_attach","title":"<code>standardize_attach(inputs, standard_attach='[*]')</code>","text":"<p>Standardize the attachment points of a molecule</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>str</code> <p>input molecule</p> required <code>standard_attach</code> <code>str</code> <p>standard attachment point to use</p> <code>'[*]'</code> Source code in <code>safe/utils.py</code> <pre><code>def standardize_attach(inputs: str, standard_attach: str = \"[*]\"):\n    \"\"\"Standardize the attachment points of a molecule\n\n    Args:\n        inputs: input molecule\n        standard_attach: standard attachment point to use\n    \"\"\"\n\n    for attach_regex in _SMILES_ATTACHMENT_POINTS:\n        inputs = re.sub(attach_regex, standard_attach, inputs)\n    return inputs\n</code></pre>"},{"location":"api/safe.models.html","title":"Model training","text":""},{"location":"api/safe.models.html#config-file","title":"Config File","text":"<p>The input config file for training a <code>SAFE</code> model is very similar to the GPT2 config file, with the addition of an optional <code>num_labels</code> attribute for training with descriptors regularization.</p> <pre><code>{\n  \"activation_function\": \"gelu_new\",\n  \"attn_pdrop\": 0.1,\n  \"bos_token_id\": 10000,\n  \"embd_pdrop\": 0.1,\n  \"eos_token_id\": 1,\n  \"initializer_range\": 0.02,\n  \"layer_norm_epsilon\": 1e-05,\n  \"model_type\": \"gpt2\",\n  \"n_embd\": 768,\n  \"n_head\": 12,\n  \"n_inner\": null,\n  \"n_layer\": 12,\n  \"n_positions\": 1024,\n  \"reorder_and_upcast_attn\": false,\n  \"resid_pdrop\": 0.1,\n  \"scale_attn_by_inverse_layer_idx\": false,\n  \"scale_attn_weights\": true,\n  \"summary_activation\": \"tanh\",\n  \"summary_first_dropout\": 0.1,\n  \"summary_proj_to_labels\": true,\n  \"summary_type\": \"cls_index\",\n  \"summary_hidden_size\": 128,\n  \"summary_use_proj\": true,\n  \"transformers_version\": \"4.31.0\",\n  \"use_cache\": true,\n  \"vocab_size\": 10000,\n  \"num_labels\": 9\n}\n</code></pre>"},{"location":"api/safe.models.html#safe-model","title":"SAFE Model","text":""},{"location":"api/safe.models.html#safe.trainer.model.PropertyHead","title":"<code>PropertyHead</code>","text":"<p>             Bases: <code>Module</code></p> <p>Compute a single vector summary of a sequence hidden states.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>[`PretrainedConfig`]</code> <p>The config used by the model. Relevant arguments in the config class of the model are (refer to the actual config class of your model for the default values it uses):</p> <ul> <li>summary_type (<code>str</code>) -- The method to use to make this summary. Accepted values are:<p>- <code>\"last\"</code> -- Take the last token hidden state (like XLNet)   - <code>\"first\"</code> -- Take the first token hidden state (like Bert)   - <code>\"mean\"</code> -- Take the mean of all tokens hidden states   - <code>\"cls_index\"</code> -- Supply a Tensor of classification token position (GPT/GPT-2)</p> </li> </ul> <ul> <li>summary_activation (<code>Optional[str]</code>) -- Set to <code>\"tanh\"</code> to add a tanh activation to the output,   another string, or <code>None</code> to add no activation.</li> </ul> required Source code in <code>safe/trainer/model.py</code> <pre><code>class PropertyHead(torch.nn.Module):\n    r\"\"\"\n    Compute a single vector summary of a sequence hidden states.\n\n    Args:\n        config ([`PretrainedConfig`]):\n            The config used by the model. Relevant arguments in the config class of the model are (refer to the actual\n            config class of your model for the default values it uses):\n\n            - **summary_type** (`str`) -- The method to use to make this summary. Accepted values are:\n\n                - `\"last\"` -- Take the last token hidden state (like XLNet)\n                - `\"first\"` -- Take the first token hidden state (like Bert)\n                - `\"mean\"` -- Take the mean of all tokens hidden states\n                - `\"cls_index\"` -- Supply a Tensor of classification token position (GPT/GPT-2)\n\n            - **summary_activation** (`Optional[str]`) -- Set to `\"tanh\"` to add a tanh activation to the output,\n              another string, or `None` to add no activation.\n    \"\"\"\n\n    def __init__(self, config: PretrainedConfig):\n        super().__init__()\n\n        self.summary_type = getattr(config, \"summary_type\", \"cls_index\")\n        self.summary = torch.nn.Identity()\n        last_hidden_size = config.hidden_size\n\n        if getattr(config, \"summary_hidden_size\", None) and config.summary_hidden_size &gt; 0:\n            self.summary = nn.Linear(config.hidden_size, config.summary_hidden_size)\n            last_hidden_size = config.summary_hidden_size\n\n        activation_string = getattr(config, \"summary_activation\", None)\n        self.activation: Callable = (\n            get_activation(activation_string) if activation_string else nn.Identity()\n        )\n\n        self.out = torch.nn.Identity()\n        if getattr(config, \"num_labels\", None) and config.num_labels &gt; 0:\n            num_labels = config.num_labels\n            self.out = nn.Linear(last_hidden_size, num_labels)\n\n    def forward(\n        self,\n        hidden_states: torch.FloatTensor,\n        cls_index: Optional[torch.LongTensor] = None,\n    ) -&gt; torch.FloatTensor:\n        \"\"\"\n        Compute a single vector summary of a sequence hidden states.\n\n        Args:\n            hidden_states: `torch.FloatTensor` of shape `[batch_size, seq_len, hidden_size]`)\n                The hidden states of the last layer.\n            cls_index: `torch.LongTensor` of shape `[batch_size]` or `[batch_size, ...]`\n                where ... are optional leading dimensions of `hidden_states`, *optional*\n                Used if `summary_type == \"cls_index\"` and takes the last token of the sequence as classification token.\n\n        Returns:\n            `torch.FloatTensor`: The summary of the sequence hidden states.\n        \"\"\"\n        if self.summary_type == \"last\":\n            output = hidden_states[:, -1]\n        elif self.summary_type == \"first\":\n            output = hidden_states[:, 0]\n        elif self.summary_type == \"mean\":\n            output = hidden_states.mean(dim=1)\n        elif self.summary_type == \"cls_index\":\n            # if cls_index is None:\n            #     cls_index = torch.full_like(\n            #         hidden_states[..., :1, :],\n            #         hidden_states.shape[-2] - 1,\n            #         dtype=torch.long,\n            #     )\n            # else:\n            #     cls_index = cls_index.unsqueeze(-1).unsqueeze(-1)\n            #     cls_index = cls_index.expand(\n            #         (-1,) * (cls_index.dim() - 1) + (hidden_states.size(-1),)\n            #     )\n\n            # shape of cls_index: (bsz, XX, 1, hidden_size) where XX are optional leading dim of hidden_states\n            # output = hidden_states.gather(-2, cls_index).squeeze(-2)  # shape (bsz, XX, hidden_size)\n            batch_size = hidden_states.shape[0]\n            output = hidden_states.squeeze()[torch.arange(batch_size), cls_index]\n        else:\n            raise NotImplementedError\n\n        output = self.summary(output)\n        output = self.activation(output)\n        return self.out(output)\n</code></pre>"},{"location":"api/safe.models.html#safe.trainer.model.PropertyHead.forward","title":"<code>forward(hidden_states, cls_index=None)</code>","text":"<p>Compute a single vector summary of a sequence hidden states.</p> <p>Parameters:</p> Name Type Description Default <code>hidden_states</code> <code>FloatTensor</code> <p><code>torch.FloatTensor</code> of shape <code>[batch_size, seq_len, hidden_size]</code>) The hidden states of the last layer.</p> required <code>cls_index</code> <code>Optional[LongTensor]</code> <p><code>torch.LongTensor</code> of shape <code>[batch_size]</code> or <code>[batch_size, ...]</code> where ... are optional leading dimensions of <code>hidden_states</code>, optional Used if <code>summary_type == \"cls_index\"</code> and takes the last token of the sequence as classification token.</p> <code>None</code> <p>Returns:</p> Type Description <code>FloatTensor</code> <p><code>torch.FloatTensor</code>: The summary of the sequence hidden states.</p> Source code in <code>safe/trainer/model.py</code> <pre><code>def forward(\n    self,\n    hidden_states: torch.FloatTensor,\n    cls_index: Optional[torch.LongTensor] = None,\n) -&gt; torch.FloatTensor:\n    \"\"\"\n    Compute a single vector summary of a sequence hidden states.\n\n    Args:\n        hidden_states: `torch.FloatTensor` of shape `[batch_size, seq_len, hidden_size]`)\n            The hidden states of the last layer.\n        cls_index: `torch.LongTensor` of shape `[batch_size]` or `[batch_size, ...]`\n            where ... are optional leading dimensions of `hidden_states`, *optional*\n            Used if `summary_type == \"cls_index\"` and takes the last token of the sequence as classification token.\n\n    Returns:\n        `torch.FloatTensor`: The summary of the sequence hidden states.\n    \"\"\"\n    if self.summary_type == \"last\":\n        output = hidden_states[:, -1]\n    elif self.summary_type == \"first\":\n        output = hidden_states[:, 0]\n    elif self.summary_type == \"mean\":\n        output = hidden_states.mean(dim=1)\n    elif self.summary_type == \"cls_index\":\n        # if cls_index is None:\n        #     cls_index = torch.full_like(\n        #         hidden_states[..., :1, :],\n        #         hidden_states.shape[-2] - 1,\n        #         dtype=torch.long,\n        #     )\n        # else:\n        #     cls_index = cls_index.unsqueeze(-1).unsqueeze(-1)\n        #     cls_index = cls_index.expand(\n        #         (-1,) * (cls_index.dim() - 1) + (hidden_states.size(-1),)\n        #     )\n\n        # shape of cls_index: (bsz, XX, 1, hidden_size) where XX are optional leading dim of hidden_states\n        # output = hidden_states.gather(-2, cls_index).squeeze(-2)  # shape (bsz, XX, hidden_size)\n        batch_size = hidden_states.shape[0]\n        output = hidden_states.squeeze()[torch.arange(batch_size), cls_index]\n    else:\n        raise NotImplementedError\n\n    output = self.summary(output)\n    output = self.activation(output)\n    return self.out(output)\n</code></pre>"},{"location":"api/safe.models.html#safe.trainer.model.SAFEDoubleHeadsModel","title":"<code>SAFEDoubleHeadsModel</code>","text":"<p>             Bases: <code>GPT2DoubleHeadsModel</code></p> <p>The safe model is a dual head GPT2 model with a language modeling head and an optional multi-task regression head</p> Source code in <code>safe/trainer/model.py</code> <pre><code>class SAFEDoubleHeadsModel(GPT2DoubleHeadsModel):\n    \"\"\"The safe model is a dual head GPT2 model with a language modeling head and an optional multi-task regression head\"\"\"\n\n    def __init__(self, config):\n        self.num_labels = getattr(config, \"num_labels\", None)\n        super().__init__(config)\n        self.config.num_labels = self.num_labels\n        del self.multiple_choice_head\n        self.multiple_choice_head = PropertyHead(config)\n\n    @add_start_docstrings_to_model_forward(GPT2_INPUTS_DOCSTRING)\n    @replace_return_docstrings(output_type=GPT2DoubleHeadsModelOutput, config_class=_CONFIG_FOR_DOC)\n    def forward(\n        self,\n        input_ids: Optional[torch.LongTensor] = None,\n        past_key_values: Optional[Tuple[Tuple[torch.Tensor]]] = None,\n        attention_mask: Optional[torch.FloatTensor] = None,\n        token_type_ids: Optional[torch.LongTensor] = None,\n        position_ids: Optional[torch.LongTensor] = None,\n        head_mask: Optional[torch.FloatTensor] = None,\n        inputs_embeds: Optional[torch.FloatTensor] = None,\n        mc_token_ids: Optional[torch.LongTensor] = None,\n        labels: Optional[torch.LongTensor] = None,\n        mc_labels: Optional[torch.LongTensor] = None,\n        use_cache: Optional[bool] = None,\n        output_attentions: Optional[bool] = None,\n        output_hidden_states: Optional[bool] = None,\n        return_dict: Optional[bool] = None,\n        inputs: Optional[Any] = None,  # do not remove because of trainer\n        **kwargs,\n    ) -&gt; Union[Tuple, GPT2DoubleHeadsModelOutput]:\n        r\"\"\"\n\n        Args:\n            mc_token_ids (`torch.LongTensor` of shape `(batch_size, num_choices)`, *optional*, default to index of the last token of the input):\n                Index of the classification token in each input sequence. Selected in the range `[0, input_ids.size(-1) -\n                1]`.\n            labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n                Labels for language modeling. Note that the labels **are shifted** inside the model, i.e. you can set\n                `labels = input_ids`. Indices are selected in `[-100, 0, ..., config.vocab_size - 1]`. All labels set to\n                `-100` are ignored (masked), the loss is only computed for labels in `[0, ..., config.vocab_size - 1]`\n            mc_labels (`torch.LongTensor` of shape `(batch_size, n_tasks)`, *optional*):\n                Labels for computing the supervized loss for regularization.\n            inputs: List of inputs, put here because the trainer removes information not in signature\n\n        Returns:\n        \"\"\"\n        return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n        transformer_outputs = self.transformer(\n            input_ids,\n            past_key_values=past_key_values,\n            attention_mask=attention_mask,\n            token_type_ids=token_type_ids,\n            position_ids=position_ids,\n            head_mask=head_mask,\n            inputs_embeds=inputs_embeds,\n            use_cache=use_cache,\n            output_attentions=output_attentions,\n            output_hidden_states=output_hidden_states,\n            return_dict=return_dict,\n        )\n\n        hidden_states = transformer_outputs[0]\n        lm_logits = self.lm_head(hidden_states)\n\n        if mc_token_ids is None and self.config.pad_token_id is not None and input_ids is not None:\n            mc_token_ids = (torch.ne(input_ids, self.config.pad_token_id).sum(-1) - 1).to(\n                lm_logits.device\n            )\n\n        # Set device for model parallelism\n        if self.model_parallel:\n            torch.cuda.set_device(self.transformer.first_device)\n            hidden_states = hidden_states.to(self.lm_head.weight.device)\n\n        mc_loss = None\n        mc_logits = None\n        if mc_labels is not None and getattr(self.config, \"num_labels\", 0) &gt; 0:\n            mc_logits = self.multiple_choice_head(hidden_states, mc_token_ids).squeeze(-1)\n            mc_labels = mc_labels.to(mc_logits.device)\n            loss_fct = MSELoss()\n            mc_loss = loss_fct(\n                mc_logits.view(-1, mc_logits.size(-1)), mc_labels.view(-1, mc_logits.size(-1))\n            )\n\n        lm_loss = None\n        if labels is not None:\n            labels = labels.to(lm_logits.device)\n            shift_logits = lm_logits[..., :-1, :].contiguous()\n            shift_labels = labels[..., 1:].contiguous()\n            loss_fct = CrossEntropyLoss()\n            lm_loss = loss_fct(shift_logits.view(-1, shift_logits.size(-1)), shift_labels.view(-1))\n\n        if not return_dict:\n            output = (lm_logits, mc_logits) + transformer_outputs[1:]\n            return (\n                lm_loss,\n                mc_loss,\n            ) + output\n\n        return GPT2DoubleHeadsModelOutput(\n            loss=lm_loss,\n            mc_loss=mc_loss,\n            logits=lm_logits,\n            mc_logits=mc_logits,\n            past_key_values=transformer_outputs.past_key_values,\n            hidden_states=transformer_outputs.hidden_states,\n            attentions=transformer_outputs.attentions,\n        )\n</code></pre>"},{"location":"api/safe.models.html#safe.trainer.model.SAFEDoubleHeadsModel.forward","title":"<code>forward(input_ids=None, past_key_values=None, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None, inputs_embeds=None, mc_token_ids=None, labels=None, mc_labels=None, use_cache=None, output_attentions=None, output_hidden_states=None, return_dict=None, inputs=None, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>mc_token_ids</code> <code>`torch.LongTensor` of shape `(batch_size, num_choices)`, *optional*, default to index of the last token of the input</code> <p>Index of the classification token in each input sequence. Selected in the range <code>[0, input_ids.size(-1) - 1]</code>.</p> <code>None</code> <code>labels</code> <code>`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*</code> <p>Labels for language modeling. Note that the labels are shifted inside the model, i.e. you can set <code>labels = input_ids</code>. Indices are selected in <code>[-100, 0, ..., config.vocab_size - 1]</code>. All labels set to <code>-100</code> are ignored (masked), the loss is only computed for labels in <code>[0, ..., config.vocab_size - 1]</code></p> <code>None</code> <code>mc_labels</code> <code>`torch.LongTensor` of shape `(batch_size, n_tasks)`, *optional*</code> <p>Labels for computing the supervized loss for regularization.</p> <code>None</code> <code>inputs</code> <code>Optional[Any]</code> <p>List of inputs, put here because the trainer removes information not in signature</p> <code>None</code> <p>Returns:</p> Source code in <code>safe/trainer/model.py</code> <pre><code>@add_start_docstrings_to_model_forward(GPT2_INPUTS_DOCSTRING)\n@replace_return_docstrings(output_type=GPT2DoubleHeadsModelOutput, config_class=_CONFIG_FOR_DOC)\ndef forward(\n    self,\n    input_ids: Optional[torch.LongTensor] = None,\n    past_key_values: Optional[Tuple[Tuple[torch.Tensor]]] = None,\n    attention_mask: Optional[torch.FloatTensor] = None,\n    token_type_ids: Optional[torch.LongTensor] = None,\n    position_ids: Optional[torch.LongTensor] = None,\n    head_mask: Optional[torch.FloatTensor] = None,\n    inputs_embeds: Optional[torch.FloatTensor] = None,\n    mc_token_ids: Optional[torch.LongTensor] = None,\n    labels: Optional[torch.LongTensor] = None,\n    mc_labels: Optional[torch.LongTensor] = None,\n    use_cache: Optional[bool] = None,\n    output_attentions: Optional[bool] = None,\n    output_hidden_states: Optional[bool] = None,\n    return_dict: Optional[bool] = None,\n    inputs: Optional[Any] = None,  # do not remove because of trainer\n    **kwargs,\n) -&gt; Union[Tuple, GPT2DoubleHeadsModelOutput]:\n    r\"\"\"\n\n    Args:\n        mc_token_ids (`torch.LongTensor` of shape `(batch_size, num_choices)`, *optional*, default to index of the last token of the input):\n            Index of the classification token in each input sequence. Selected in the range `[0, input_ids.size(-1) -\n            1]`.\n        labels (`torch.LongTensor` of shape `(batch_size, sequence_length)`, *optional*):\n            Labels for language modeling. Note that the labels **are shifted** inside the model, i.e. you can set\n            `labels = input_ids`. Indices are selected in `[-100, 0, ..., config.vocab_size - 1]`. All labels set to\n            `-100` are ignored (masked), the loss is only computed for labels in `[0, ..., config.vocab_size - 1]`\n        mc_labels (`torch.LongTensor` of shape `(batch_size, n_tasks)`, *optional*):\n            Labels for computing the supervized loss for regularization.\n        inputs: List of inputs, put here because the trainer removes information not in signature\n\n    Returns:\n    \"\"\"\n    return_dict = return_dict if return_dict is not None else self.config.use_return_dict\n    transformer_outputs = self.transformer(\n        input_ids,\n        past_key_values=past_key_values,\n        attention_mask=attention_mask,\n        token_type_ids=token_type_ids,\n        position_ids=position_ids,\n        head_mask=head_mask,\n        inputs_embeds=inputs_embeds,\n        use_cache=use_cache,\n        output_attentions=output_attentions,\n        output_hidden_states=output_hidden_states,\n        return_dict=return_dict,\n    )\n\n    hidden_states = transformer_outputs[0]\n    lm_logits = self.lm_head(hidden_states)\n\n    if mc_token_ids is None and self.config.pad_token_id is not None and input_ids is not None:\n        mc_token_ids = (torch.ne(input_ids, self.config.pad_token_id).sum(-1) - 1).to(\n            lm_logits.device\n        )\n\n    # Set device for model parallelism\n    if self.model_parallel:\n        torch.cuda.set_device(self.transformer.first_device)\n        hidden_states = hidden_states.to(self.lm_head.weight.device)\n\n    mc_loss = None\n    mc_logits = None\n    if mc_labels is not None and getattr(self.config, \"num_labels\", 0) &gt; 0:\n        mc_logits = self.multiple_choice_head(hidden_states, mc_token_ids).squeeze(-1)\n        mc_labels = mc_labels.to(mc_logits.device)\n        loss_fct = MSELoss()\n        mc_loss = loss_fct(\n            mc_logits.view(-1, mc_logits.size(-1)), mc_labels.view(-1, mc_logits.size(-1))\n        )\n\n    lm_loss = None\n    if labels is not None:\n        labels = labels.to(lm_logits.device)\n        shift_logits = lm_logits[..., :-1, :].contiguous()\n        shift_labels = labels[..., 1:].contiguous()\n        loss_fct = CrossEntropyLoss()\n        lm_loss = loss_fct(shift_logits.view(-1, shift_logits.size(-1)), shift_labels.view(-1))\n\n    if not return_dict:\n        output = (lm_logits, mc_logits) + transformer_outputs[1:]\n        return (\n            lm_loss,\n            mc_loss,\n        ) + output\n\n    return GPT2DoubleHeadsModelOutput(\n        loss=lm_loss,\n        mc_loss=mc_loss,\n        logits=lm_logits,\n        mc_logits=mc_logits,\n        past_key_values=transformer_outputs.past_key_values,\n        hidden_states=transformer_outputs.hidden_states,\n        attentions=transformer_outputs.attentions,\n    )\n</code></pre>"},{"location":"api/safe.models.html#trainer","title":"Trainer","text":""},{"location":"api/safe.models.html#safe.trainer.trainer_utils.SAFETrainer","title":"<code>SAFETrainer</code>","text":"<p>             Bases: <code>Trainer</code></p> <p>Custom trainer for training SAFE model.</p> <p>This custom trainer changes the loss function to support the property head</p> Source code in <code>safe/trainer/trainer_utils.py</code> <pre><code>class SAFETrainer(Trainer):\n    \"\"\"\n    Custom trainer for training SAFE model.\n\n    This custom trainer changes the loss function to support the property head\n\n    \"\"\"\n\n    def __init__(\n        self, *args, prop_loss_coeff: float = 1e-3, dispatch_batches: bool = False, **kwargs\n    ):\n        super().__init__(*args, **kwargs)\n        self.prop_loss_coeff = prop_loss_coeff\n        self.accelerator.dispatch_batches = dispatch_batches\n\n    def compute_loss(self, model, inputs, return_outputs=False):\n        \"\"\"\n        How the loss is computed by Trainer. By default, all models return the loss in the first element.\n        \"\"\"\n        labels = (\n            inputs.pop(\"labels\") if self.label_smoother is not None and \"labels\" in inputs else None\n        )\n\n        outputs = model(**inputs)\n        # Save past state if it exists\n        # TODO: this needs to be fixed and made cleaner later.\n        if self.args.past_index &gt;= 0:\n            self._past = outputs[self.args.past_index]\n\n        if labels is not None:\n            if unwrap_model(model)._get_name() in MODEL_FOR_CAUSAL_LM_MAPPING_NAMES.values():\n                loss = self.label_smoother(outputs, labels, shift_labels=True)\n            else:\n                loss = self.label_smoother(outputs, labels)\n        else:\n            if isinstance(outputs, dict) and \"loss\" not in outputs:\n                raise ValueError(\n                    \"The model did not return a loss from the inputs, only the following keys: \"\n                    f\"{','.join(outputs.keys())}. For reference, the inputs it received are {','.join(inputs.keys())}.\"\n                )\n            # We don't use .loss here since the model may return tuples instead of ModelOutput.\n            loss = outputs[\"loss\"] if isinstance(outputs, dict) else outputs[0]\n        mc_loss = outputs.get(\"mc_loss\", None) if isinstance(outputs, dict) else outputs[1]\n        if mc_loss is not None:\n            loss = loss + self.prop_loss_coeff * mc_loss\n        return (loss, outputs) if return_outputs else loss\n</code></pre>"},{"location":"api/safe.models.html#safe.trainer.trainer_utils.SAFETrainer.compute_loss","title":"<code>compute_loss(model, inputs, return_outputs=False)</code>","text":"<p>How the loss is computed by Trainer. By default, all models return the loss in the first element.</p> Source code in <code>safe/trainer/trainer_utils.py</code> <pre><code>def compute_loss(self, model, inputs, return_outputs=False):\n    \"\"\"\n    How the loss is computed by Trainer. By default, all models return the loss in the first element.\n    \"\"\"\n    labels = (\n        inputs.pop(\"labels\") if self.label_smoother is not None and \"labels\" in inputs else None\n    )\n\n    outputs = model(**inputs)\n    # Save past state if it exists\n    # TODO: this needs to be fixed and made cleaner later.\n    if self.args.past_index &gt;= 0:\n        self._past = outputs[self.args.past_index]\n\n    if labels is not None:\n        if unwrap_model(model)._get_name() in MODEL_FOR_CAUSAL_LM_MAPPING_NAMES.values():\n            loss = self.label_smoother(outputs, labels, shift_labels=True)\n        else:\n            loss = self.label_smoother(outputs, labels)\n    else:\n        if isinstance(outputs, dict) and \"loss\" not in outputs:\n            raise ValueError(\n                \"The model did not return a loss from the inputs, only the following keys: \"\n                f\"{','.join(outputs.keys())}. For reference, the inputs it received are {','.join(inputs.keys())}.\"\n            )\n        # We don't use .loss here since the model may return tuples instead of ModelOutput.\n        loss = outputs[\"loss\"] if isinstance(outputs, dict) else outputs[0]\n    mc_loss = outputs.get(\"mc_loss\", None) if isinstance(outputs, dict) else outputs[1]\n    if mc_loss is not None:\n        loss = loss + self.prop_loss_coeff * mc_loss\n    return (loss, outputs) if return_outputs else loss\n</code></pre>"},{"location":"api/safe.models.html#data-collator","title":"Data Collator","text":""},{"location":"api/safe.models.html#safe.trainer.collator.SAFECollator","title":"<code>SAFECollator</code>","text":"<p>Collate function for language modelling tasks</p> <p>Note</p> <p>The collate function is based on the default DataCollatorForLanguageModeling in huggingface see: https://github.com/huggingface/transformers/blob/v4.19.2/src/transformers/data/data_collator.py</p> Source code in <code>safe/trainer/collator.py</code> <pre><code>class SAFECollator:\n    \"\"\"Collate function for language modelling tasks\n\n\n    !!! note\n        The collate function is based on the default DataCollatorForLanguageModeling in huggingface\n        see: https://github.com/huggingface/transformers/blob/v4.19.2/src/transformers/data/data_collator.py\n    \"\"\"\n\n    def __init__(\n        self,\n        tokenizer: Tokenizer,\n        pad_to_multiple_of: Optional[int] = None,\n        input_key: str = \"inputs\",\n        label_key: str = \"labels\",\n        property_key: str = \"descriptors\",\n        include_descriptors: bool = False,\n        max_length: Optional[int] = None,\n    ):\n        \"\"\"\n        Default collator for huggingface transformers in izanagi.\n\n        Args:\n            tokenizer: Huggingface tokenizer\n            input_key: key to use for input ids\n            label_key: key to use for labels\n            property_key: key to use for properties\n            include_descriptors: whether to include training on descriptors or not\n            pad_to_multiple_of: pad to multiple of this value\n        \"\"\"\n\n        self.tokenizer = tokenizer\n        self.pad_to_multiple_of = pad_to_multiple_of\n        self.input_key = input_key\n        self.label_key = label_key\n        self.property_key = property_key\n        self.include_descriptors = include_descriptors\n        self.max_length = max_length\n\n    @functools.lru_cache()\n    def get_tokenizer(self):\n        \"\"\"Get underlying tokenizer\"\"\"\n        if isinstance(self.tokenizer, SAFETokenizer):\n            return self.tokenizer.get_pretrained()\n        return self.tokenizer\n\n    def __call__(self, samples: List[Union[List[int], Any, Dict[str, Any]]]):\n        \"\"\"\n        Call collate function\n\n        Args:\n            samples: list of examples\n        \"\"\"\n        # Handle dict or lists with proper padding and conversion to tensor.\n        tokenizer = self.get_tokenizer()\n\n        # examples = samples\n        examples = copy.deepcopy(samples)\n        inputs = [example.pop(self.input_key, None) for example in examples]\n        mc_labels = (\n            torch.tensor([example.pop(self.property_key, None) for example in examples]).float()\n            if self.property_key in examples[0]\n            else None\n        )\n\n        if \"input_ids\" not in examples[0] and inputs is not None:\n            batch = tokenizer(\n                inputs,\n                return_tensors=\"pt\",\n                padding=True,\n                truncation=True,\n                max_length=self.max_length,\n                pad_to_multiple_of=self.pad_to_multiple_of,\n            )\n        else:\n            batch = tokenizer.pad(\n                examples,\n                return_tensors=\"pt\",\n                padding=True,\n                pad_to_multiple_of=self.pad_to_multiple_of,\n                max_length=self.max_length,\n            )\n\n        # If special token mask has been preprocessed, pop it from the dict.\n        batch.pop(\"special_tokens_mask\", None)\n        labels = batch.get(\"labels\", batch[\"input_ids\"].clone())\n        if tokenizer.pad_token_id is not None:\n            labels[labels == tokenizer.pad_token_id] = -100\n        batch[\"labels\"] = labels\n\n        if mc_labels is not None and self.include_descriptors:\n            batch.update(\n                {\n                    \"mc_labels\": mc_labels,\n                    # \"input_text\": inputs,\n                }\n            )\n        return batch\n</code></pre>"},{"location":"api/safe.models.html#safe.trainer.collator.SAFECollator.__call__","title":"<code>__call__(samples)</code>","text":"<p>Call collate function</p> <p>Parameters:</p> Name Type Description Default <code>samples</code> <code>List[Union[List[int], Any, Dict[str, Any]]]</code> <p>list of examples</p> required Source code in <code>safe/trainer/collator.py</code> <pre><code>def __call__(self, samples: List[Union[List[int], Any, Dict[str, Any]]]):\n    \"\"\"\n    Call collate function\n\n    Args:\n        samples: list of examples\n    \"\"\"\n    # Handle dict or lists with proper padding and conversion to tensor.\n    tokenizer = self.get_tokenizer()\n\n    # examples = samples\n    examples = copy.deepcopy(samples)\n    inputs = [example.pop(self.input_key, None) for example in examples]\n    mc_labels = (\n        torch.tensor([example.pop(self.property_key, None) for example in examples]).float()\n        if self.property_key in examples[0]\n        else None\n    )\n\n    if \"input_ids\" not in examples[0] and inputs is not None:\n        batch = tokenizer(\n            inputs,\n            return_tensors=\"pt\",\n            padding=True,\n            truncation=True,\n            max_length=self.max_length,\n            pad_to_multiple_of=self.pad_to_multiple_of,\n        )\n    else:\n        batch = tokenizer.pad(\n            examples,\n            return_tensors=\"pt\",\n            padding=True,\n            pad_to_multiple_of=self.pad_to_multiple_of,\n            max_length=self.max_length,\n        )\n\n    # If special token mask has been preprocessed, pop it from the dict.\n    batch.pop(\"special_tokens_mask\", None)\n    labels = batch.get(\"labels\", batch[\"input_ids\"].clone())\n    if tokenizer.pad_token_id is not None:\n        labels[labels == tokenizer.pad_token_id] = -100\n    batch[\"labels\"] = labels\n\n    if mc_labels is not None and self.include_descriptors:\n        batch.update(\n            {\n                \"mc_labels\": mc_labels,\n                # \"input_text\": inputs,\n            }\n        )\n    return batch\n</code></pre>"},{"location":"api/safe.models.html#safe.trainer.collator.SAFECollator.__init__","title":"<code>__init__(tokenizer, pad_to_multiple_of=None, input_key='inputs', label_key='labels', property_key='descriptors', include_descriptors=False, max_length=None)</code>","text":"<p>Default collator for huggingface transformers in izanagi.</p> <p>Parameters:</p> Name Type Description Default <code>tokenizer</code> <code>Tokenizer</code> <p>Huggingface tokenizer</p> required <code>input_key</code> <code>str</code> <p>key to use for input ids</p> <code>'inputs'</code> <code>label_key</code> <code>str</code> <p>key to use for labels</p> <code>'labels'</code> <code>property_key</code> <code>str</code> <p>key to use for properties</p> <code>'descriptors'</code> <code>include_descriptors</code> <code>bool</code> <p>whether to include training on descriptors or not</p> <code>False</code> <code>pad_to_multiple_of</code> <code>Optional[int]</code> <p>pad to multiple of this value</p> <code>None</code> Source code in <code>safe/trainer/collator.py</code> <pre><code>def __init__(\n    self,\n    tokenizer: Tokenizer,\n    pad_to_multiple_of: Optional[int] = None,\n    input_key: str = \"inputs\",\n    label_key: str = \"labels\",\n    property_key: str = \"descriptors\",\n    include_descriptors: bool = False,\n    max_length: Optional[int] = None,\n):\n    \"\"\"\n    Default collator for huggingface transformers in izanagi.\n\n    Args:\n        tokenizer: Huggingface tokenizer\n        input_key: key to use for input ids\n        label_key: key to use for labels\n        property_key: key to use for properties\n        include_descriptors: whether to include training on descriptors or not\n        pad_to_multiple_of: pad to multiple of this value\n    \"\"\"\n\n    self.tokenizer = tokenizer\n    self.pad_to_multiple_of = pad_to_multiple_of\n    self.input_key = input_key\n    self.label_key = label_key\n    self.property_key = property_key\n    self.include_descriptors = include_descriptors\n    self.max_length = max_length\n</code></pre>"},{"location":"api/safe.models.html#safe.trainer.collator.SAFECollator.get_tokenizer","title":"<code>get_tokenizer()</code>  <code>cached</code>","text":"<p>Get underlying tokenizer</p> Source code in <code>safe/trainer/collator.py</code> <pre><code>@functools.lru_cache()\ndef get_tokenizer(self):\n    \"\"\"Get underlying tokenizer\"\"\"\n    if isinstance(self.tokenizer, SAFETokenizer):\n        return self.tokenizer.get_pretrained()\n    return self.tokenizer\n</code></pre>"},{"location":"api/safe.models.html#data-utils","title":"Data Utils","text":""},{"location":"api/safe.models.html#safe.trainer.data_utils.get_dataset","title":"<code>get_dataset(data_path, name=None, tokenizer=None, cache_dir=None, streaming=True, use_auth_token=False, tokenize_column='inputs', property_column='descriptors', max_length=None, num_shards=1024)</code>","text":"<p>Get the datasets from the config file</p> Source code in <code>safe/trainer/data_utils.py</code> <pre><code>def get_dataset(\n    data_path,\n    name: Optional[str] = None,\n    tokenizer: Optional[Callable] = None,\n    cache_dir: Optional[str] = None,\n    streaming: bool = True,\n    use_auth_token: bool = False,\n    tokenize_column: Optional[str] = \"inputs\",\n    property_column: Optional[str] = \"descriptors\",\n    max_length: Optional[int] = None,\n    num_shards=1024,\n):\n    \"\"\"Get the datasets from the config file\"\"\"\n    raw_datasets = {}\n    if data_path is not None:\n        data_path = upath.UPath(str(data_path))\n\n        if data_path.exists():\n            # the we need to load from disk\n            data_path = str(data_path)\n            # for some reason, the datasets package is not able to load the dataset\n            # because the split where not originally proposed\n            raw_datasets = datasets.load_from_disk(data_path)\n\n            if streaming:\n                if isinstance(raw_datasets, datasets.DatasetDict):\n                    previous_num_examples = {k: len(dt) for k, dt in raw_datasets.items()}\n                    raw_datasets = datasets.IterableDatasetDict(\n                        {\n                            k: dt.to_iterable_dataset(num_shards=num_shards)\n                            for k, dt in raw_datasets.items()\n                        }\n                    )\n                    for k, dt in raw_datasets.items():\n                        if previous_num_examples[k] is not None:\n                            setattr(dt, \"num_examples\", previous_num_examples[k])\n                else:\n                    num_examples = len(raw_datasets)\n                    raw_datasets = raw_datasets.to_iterable_dataset(num_shards=num_shards)\n                    setattr(raw_datasets, \"num_examples\", num_examples)\n\n        else:\n            raw_datasets = datasets.load_dataset(\n                data_path,\n                name=name,\n                cache_dir=cache_dir,\n                use_auth_token=True if use_auth_token else None,\n                streaming=streaming,\n            )\n    # that means we need to return a tokenized version of the dataset\n\n    if property_column not in [\"mc_labels\", None]:\n        raw_datasets = raw_datasets.rename_column(property_column, \"mc_labels\")\n\n    columns_to_remove = None\n    if tokenize_column is not None:\n        columns_to_remove = [\n            x\n            for x in (get_dataset_column_names(raw_datasets) or [])\n            if x not in [tokenize_column, \"mc_labels\"] and \"label\" not in x\n        ] or None\n\n    if tokenizer is None:\n        if columns_to_remove is not None:\n            raw_datasets = raw_datasets.remove_columns(columns_to_remove)\n        return raw_datasets\n\n    return raw_datasets.map(\n        partial(\n            tokenize_fn,\n            tokenizer=tokenizer,\n            tokenize_column=tokenize_column,\n            max_length=max_length,\n        ),\n        batched=True,\n        remove_columns=columns_to_remove,\n    )\n</code></pre>"},{"location":"api/safe.models.html#safe.trainer.data_utils.get_dataset_column_names","title":"<code>get_dataset_column_names(dataset)</code>","text":"<p>Get the column names in a dataset Args:     dataset: dataset to get the column names from</p> Source code in <code>safe/trainer/data_utils.py</code> <pre><code>def get_dataset_column_names(dataset):\n    \"\"\"Get the column names in a dataset\n    Args:\n        dataset: dataset to get the column names from\n    \"\"\"\n    if isinstance(dataset, (datasets.IterableDatasetDict, Mapping)):\n        column_names = {split: dataset[split].column_names for split in dataset}\n    else:\n        column_names = dataset.column_names\n    if isinstance(column_names, dict):\n        column_names = list(column_names.values())[0]\n    return column_names\n</code></pre>"},{"location":"api/safe.models.html#safe.trainer.data_utils.take","title":"<code>take(n, iterable)</code>","text":"<p>Return first n items of the iterable as a list</p> Source code in <code>safe/trainer/data_utils.py</code> <pre><code>def take(n, iterable):\n    \"Return first n items of the iterable as a list\"\n    return list(itertools.islice(iterable, n))\n</code></pre>"},{"location":"api/safe.models.html#safe.trainer.data_utils.tokenize_fn","title":"<code>tokenize_fn(row, tokenizer, tokenize_column='inputs', max_length=None, padding=False)</code>","text":"<p>Perform the tokenization of a row Args:     row: row to tokenize     tokenizer: tokenizer to use     tokenize_column: column to tokenize     max_length: maximum size of the tokenized sequence     padding: whether to pad the sequence</p> Source code in <code>safe/trainer/data_utils.py</code> <pre><code>def tokenize_fn(\n    row,\n    tokenizer,\n    tokenize_column: str = \"inputs\",\n    max_length: Optional[int] = None,\n    padding: bool = False,\n):\n    \"\"\"Perform the tokenization of a row\n    Args:\n        row: row to tokenize\n        tokenizer: tokenizer to use\n        tokenize_column: column to tokenize\n        max_length: maximum size of the tokenized sequence\n        padding: whether to pad the sequence\n    \"\"\"\n    # there's probably a way to do this with the tokenizer settings\n    # but again, gotta move fast\n\n    fast_tokenizer = (\n        tokenizer.get_pretrained() if isinstance(tokenizer, SAFETokenizer) else tokenizer\n    )\n\n    return fast_tokenizer(\n        row[tokenize_column],\n        truncation=(max_length is not None),\n        max_length=max_length,\n        padding=padding,\n        return_tensors=None,\n    )\n</code></pre>"},{"location":"api/safe.viz.html","title":"Visualization","text":""},{"location":"api/safe.viz.html#safe.viz.to_image","title":"<code>to_image(safe_str, fragments=None, legend=None, mol_size=(300, 300), use_svg=True, highlight_mode='lasso', highlight_bond_width_multiplier=12, **kwargs)</code>","text":"<p>Display a safe string by highlighting the fragments that make it.</p> <p>Parameters:</p> Name Type Description Default <code>safe_str</code> <code>str</code> <p>the safe string to display</p> required <code>fragments</code> <code>Optional[Union[str, Mol]]</code> <p>list of fragment to highlight on the molecules. If None, will use safe decomposition of the molecule.</p> <code>None</code> <code>legend</code> <code>Union[str, None]</code> <p>A string to use as the legend under the molecule.</p> <code>None</code> <code>mol_size</code> <code>Union[Tuple[int, int], int]</code> <p>The size of the image to be returned</p> <code>(300, 300)</code> <code>use_svg</code> <code>Optional[bool]</code> <p>Whether to return an svg or png image</p> <code>True</code> <code>highlight_mode</code> <code>Optional[str]</code> <p>the highlight mode to use. One of [\"lasso\", \"fill\", \"color\"]. If None, no highlight will be shown</p> <code>'lasso'</code> <code>highlight_bond_width_multiplier</code> <code>int</code> <p>the multiplier to use for the bond width when using the 'fill' mode</p> <code>12</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments to pass to the drawing function. See RDKit documentation related to <code>MolDrawOptions</code> for more details at https://www.rdkit.org/docs/source/rdkit.Chem.Draw.rdMolDraw2D.html.</p> <code>{}</code> Source code in <code>safe/viz.py</code> <pre><code>def to_image(\n    safe_str: str,\n    fragments: Optional[Union[str, dm.Mol]] = None,\n    legend: Union[str, None] = None,\n    mol_size: Union[Tuple[int, int], int] = (300, 300),\n    use_svg: Optional[bool] = True,\n    highlight_mode: Optional[str] = \"lasso\",\n    highlight_bond_width_multiplier: int = 12,\n    **kwargs: Any,\n):\n    \"\"\"Display a safe string by highlighting the fragments that make it.\n\n    Args:\n        safe_str: the safe string to display\n        fragments: list of fragment to highlight on the molecules. If None, will use safe decomposition of the molecule.\n        legend: A string to use as the legend under the molecule.\n        mol_size: The size of the image to be returned\n        use_svg: Whether to return an svg or png image\n        highlight_mode: the highlight mode to use. One of [\"lasso\", \"fill\", \"color\"]. If None, no highlight will be shown\n        highlight_bond_width_multiplier: the multiplier to use for the bond width when using the 'fill' mode\n        **kwargs: Additional arguments to pass to the drawing function. See RDKit\n            documentation related to `MolDrawOptions` for more details at\n            https://www.rdkit.org/docs/source/rdkit.Chem.Draw.rdMolDraw2D.html.\n\n    \"\"\"\n\n    kwargs[\"legends\"] = legend\n    kwargs[\"mol_size\"] = mol_size\n    kwargs[\"use_svg\"] = use_svg\n    if highlight_bond_width_multiplier is not None:\n        kwargs[\"highlightBondWidthMultiplier\"] = highlight_bond_width_multiplier\n\n    if highlight_mode == \"color\":\n        kwargs[\"continuousHighlight\"] = False\n        kwargs[\"circleAtoms\"] = kwargs.get(\"circleAtoms\", False) or False\n\n    if isinstance(fragments, (str, dm.Mol)):\n        fragments = [fragments]\n\n    if fragments is None and highlight_mode is not None:\n        fragments = [\n            sf.decode(x, as_mol=False, remove_dummies=False, ignore_errors=False)\n            for x in safe_str.split(\".\")\n        ]\n    else:\n        parsed_fragments = []\n        for fg in fragments:\n            if isinstance(fg, str) and dm.to_mol(fg) is None:\n                fg = sf.decode(fg, as_mol=False, remove_dummies=False, ignore_errors=False)\n        parsed_fragments.append(fg)\n        fragments = parsed_fragments\n    mol = dm.to_mol(safe_str, remove_hs=False)\n    cm = plt.get_cmap(\"gist_rainbow\")\n    current_colors = [cm(1.0 * i / len(fragments)) for i in range(len(fragments))]\n\n    if highlight_mode == \"lasso\":\n        return dm.viz.lasso_highlight_image(mol, fragments, **kwargs)\n\n    atom_indices = []\n    bond_indices = []\n    atom_colors = {}\n    bond_colors = {}\n\n    for i, frag in enumerate(fragments):\n        frag = dm.from_smarts(frag)\n        atom_matches, bond_matches = dm.substructure_matching_bonds(mol, frag)\n        atom_matches = list(itertools.chain(*atom_matches))\n        bond_matches = list(itertools.chain(*bond_matches))\n        atom_indices.extend(atom_matches)\n        bond_indices.extend(bond_matches)\n        atom_colors.update({x: current_colors[i] for x in atom_matches})\n        bond_colors.update({x: current_colors[i] for x in bond_matches})\n\n    return dm.viz.to_image(\n        mol,\n        highlight_atom=[atom_indices],\n        highlight_bond=[bond_indices],\n        highlightAtomColors=[atom_colors],\n        highlightBondColors=[bond_colors],\n        **kwargs,\n    )\n</code></pre>"},{"location":"tutorials/design-with-safe.html","title":"Molecular design with Pretrained SAFE","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n</pre> %load_ext autoreload %autoreload 2  In\u00a0[1]: Copied! <pre>import os\n\n\nos.environ[\"TOKENIZERS_PARALLELISM\"] = \"false\"\n\n\nimport safe as sf\nimport datamol as dm\n</pre> import os   os.environ[\"TOKENIZERS_PARALLELISM\"] = \"false\"   import safe as sf import datamol as dm  In\u00a0[2]: Copied! <pre># designer = sf.SAFEDesign.load_default(verbose=True)\n</pre> # designer = sf.SAFEDesign.load_default(verbose=True)  <pre>\n---------------------------------------------------------------------------\nHFValidationError                         Traceback (most recent call last)\n/home/hadim/Code/valence/Libs/safe/docs/tutorials/design-with-safe.ipynb Cell 3 line 1\n----&gt; &lt;a href='vscode-notebook-cell:/home/hadim/Code/valence/Libs/safe/docs/tutorials/design-with-safe.ipynb#W4sZmlsZQ%3D%3D?line=0'&gt;1&lt;/a&gt; designer = sf.SAFEDesign.load_default(verbose=True)\n\nFile ~/Code/valence/Libs/safe/safe/sample.py:89, in SAFEDesign.load_default(cls, verbose, model_dir, device)\n     87 if model_dir is None or not model_dir:\n     88     model_dir = cls._DEFAULT_MODEL_PATH\n---&gt; 89 model = SAFEDoubleHeadsModel.from_pretrained(model_dir)\n     90 tokenizer = SAFETokenizer.load(os.path.join(model_dir, \"tokenizer.json\"))\n     91 gen_config = GenerationConfig.from_pretrained(model_dir)\n\nFile ~/local/micromamba/envs/safe/lib/python3.11/site-packages/transformers/modeling_utils.py:2507, in PreTrainedModel.from_pretrained(cls, pretrained_model_name_or_path, config, cache_dir, ignore_mismatched_sizes, force_download, local_files_only, token, revision, use_safetensors, *model_args, **kwargs)\n   2504 if commit_hash is None:\n   2505     if not isinstance(config, PretrainedConfig):\n   2506         # We make a call to the config file first (which may be absent) to get the commit hash as soon as possible\n-&gt; 2507         resolved_config_file = cached_file(\n   2508             pretrained_model_name_or_path,\n   2509             CONFIG_NAME,\n   2510             cache_dir=cache_dir,\n   2511             force_download=force_download,\n   2512             resume_download=resume_download,\n   2513             proxies=proxies,\n   2514             local_files_only=local_files_only,\n   2515             token=token,\n   2516             revision=revision,\n   2517             subfolder=subfolder,\n   2518             _raise_exceptions_for_missing_entries=False,\n   2519             _raise_exceptions_for_connection_errors=False,\n   2520         )\n   2521         commit_hash = extract_commit_hash(resolved_config_file, commit_hash)\n   2522     else:\n\nFile ~/local/micromamba/envs/safe/lib/python3.11/site-packages/transformers/utils/hub.py:429, in cached_file(path_or_repo_id, filename, cache_dir, force_download, resume_download, proxies, token, revision, local_files_only, subfolder, repo_type, user_agent, _raise_exceptions_for_missing_entries, _raise_exceptions_for_connection_errors, _commit_hash, **deprecated_kwargs)\n    426 user_agent = http_user_agent(user_agent)\n    427 try:\n    428     # Load from URL or cache if already cached\n--&gt; 429     resolved_file = hf_hub_download(\n    430         path_or_repo_id,\n    431         filename,\n    432         subfolder=None if len(subfolder) == 0 else subfolder,\n    433         repo_type=repo_type,\n    434         revision=revision,\n    435         cache_dir=cache_dir,\n    436         user_agent=user_agent,\n    437         force_download=force_download,\n    438         proxies=proxies,\n    439         resume_download=resume_download,\n    440         token=token,\n    441         local_files_only=local_files_only,\n    442     )\n    443 except GatedRepoError as e:\n    444     raise EnvironmentError(\n    445         \"You are trying to access a gated repo.\\nMake sure to request access at \"\n    446         f\"https://huggingface.co/{path_or_repo_id} and pass a token having permission to this repo either \"\n    447         \"by logging in with `huggingface-cli login` or by passing `token=&lt;your_token&gt;`.\"\n    448     ) from e\n\nFile ~/local/micromamba/envs/safe/lib/python3.11/site-packages/huggingface_hub/utils/_validators.py:110, in validate_hf_hub_args.&lt;locals&gt;._inner_fn(*args, **kwargs)\n    105 for arg_name, arg_value in chain(\n    106     zip(signature.parameters, args),  # Args values\n    107     kwargs.items(),  # Kwargs values\n    108 ):\n    109     if arg_name in [\"repo_id\", \"from_id\", \"to_id\"]:\n--&gt; 110         validate_repo_id(arg_value)\n    112     elif arg_name == \"token\" and arg_value is not None:\n    113         has_token = True\n\nFile ~/local/micromamba/envs/safe/lib/python3.11/site-packages/huggingface_hub/utils/_validators.py:158, in validate_repo_id(repo_id)\n    155     raise HFValidationError(f\"Repo id must be a string, not {type(repo_id)}: '{repo_id}'.\")\n    157 if repo_id.count(\"/\") &gt; 1:\n--&gt; 158     raise HFValidationError(\n    159         \"Repo id must be in the form 'repo_name' or 'namespace/repo_name':\"\n    160         f\" '{repo_id}'. Use `repo_type` argument if needed.\"\n    161     )\n    163 if not REPO_ID_REGEX.match(repo_id):\n    164     raise HFValidationError(\n    165         \"Repo id must use alphanumeric chars or '-', '_', '.', '--' and '..' are\"\n    166         \" forbidden, '-' and '.' cannot start or end the name, max length is 96:\"\n    167         f\" '{repo_id}'.\"\n    168     )\n\nHFValidationError: Repo id must be in the form 'repo_name' or 'namespace/repo_name': '/home/hadim/.cache/safe/default_model'. Use `repo_type` argument if needed.</pre> In\u00a0[30]: Copied! <pre># candidate_mol = \"O=C(C#CCN1CCCCC1)Nc1ccc2ncnc(Nc3cccc(Br)c3)c2c1\"\n\n# scaffold = \"[*]N-c1ccc2ncnc(-N[*])c2c1\" # this is for scaffold decoration\n# superstructure = \"c1ccc2ncncc2c1\"\n# side_chains = '[1*]C(=O)C#CCN1CCCCC1.[2*]c1cccc(Br)c1' # this is for scaffold morphing\n# motif = \"[*]-N1CCCCC1\" # this is for motif extension\n# linker_generation = [\"[*]-N1CCCCC1\", \"Brc1cccc(Nc2ncnc3ccc(-[*])cc23)c1\"] # this is for linker generation\n</pre> # candidate_mol = \"O=C(C#CCN1CCCCC1)Nc1ccc2ncnc(Nc3cccc(Br)c3)c2c1\"  # scaffold = \"[*]N-c1ccc2ncnc(-N[*])c2c1\" # this is for scaffold decoration # superstructure = \"c1ccc2ncncc2c1\" # side_chains = '[1*]C(=O)C#CCN1CCCCC1.[2*]c1cccc(Br)c1' # this is for scaffold morphing # motif = \"[*]-N1CCCCC1\" # this is for motif extension # linker_generation = [\"[*]-N1CCCCC1\", \"Brc1cccc(Nc2ncnc3ccc(-[*])cc23)c1\"] # this is for linker generation  <p>We start with the image shown in the README of the SAFE GitHub Repository to assess the performance on the various tasks SAFE should in theory be good at.</p> In\u00a0[31]: Copied! <pre># dm.to_image(dm.to_mol(candidate_mol))\n</pre> # dm.to_image(dm.to_mol(candidate_mol))  Out[31]: In\u00a0[32]: Copied! <pre># N_SAMPLES = 100\n</pre> # N_SAMPLES = 100  In\u00a0[33]: Copied! <pre># generated = designer.de_novo_generation(sanitize=True, n_samples_per_trial=N_SAMPLES)\n</pre> # generated = designer.de_novo_generation(sanitize=True, n_samples_per_trial=N_SAMPLES)  <pre>2023-08-29 16:58:21.338 | INFO     | safe.sample:de_novo_generation:559 - After sanitization, 83 / 100 (83.00 %)  generated molecules are valid !\n</pre> In\u00a0[34]: Copied! <pre># dm.to_image(generated[:20])\n</pre> # dm.to_image(generated[:20])  Out[34]: In\u00a0[35]: Copied! <pre># dm.to_image(scaffold)\n</pre> # dm.to_image(scaffold)  Out[35]: In\u00a0[36]: Copied! <pre># generated = designer.scaffold_decoration(scaffold=scaffold, n_samples_per_trial=N_SAMPLES, n_trials=2, sanitize=True, do_not_fragment_further=True)\n</pre> # generated = designer.scaffold_decoration(scaffold=scaffold, n_samples_per_trial=N_SAMPLES, n_trials=2, sanitize=True, do_not_fragment_further=True)  <pre>2023-08-29 16:59:49.566 | INFO     | safe.sample:scaffold_decoration:534 - After sanitization, 182 / 200 (91.00 %)  generated molecules are valid !\n</pre> In\u00a0[37]: Copied! <pre># dm.viz.lasso_highlight_image([dm.to_mol(x) for x in generated[:20]], dm.from_smarts(scaffold))\n</pre> # dm.viz.lasso_highlight_image([dm.to_mol(x) for x in generated[:20]], dm.from_smarts(scaffold))  Out[37]: In\u00a0[38]: Copied! <pre># dm.to_image(superstructure)\n</pre> # dm.to_image(superstructure)  Out[38]: In\u00a0[39]: Copied! <pre># generated = designer.super_structure(core=superstructure, n_samples_per_trial=N_SAMPLES, n_trials=1, sanitize=True, do_not_fragment_further=False, attachment_point_depth=3)\n# #generated\n</pre> # generated = designer.super_structure(core=superstructure, n_samples_per_trial=N_SAMPLES, n_trials=1, sanitize=True, do_not_fragment_further=False, attachment_point_depth=3) # #generated  <pre>2023-08-29 16:59:56.491 | INFO     | safe.sample:super_structure:488 - After sanitization, 41 / 100 (41.00 %)  generated molecules are valid !\n</pre> In\u00a0[40]: Copied! <pre># dm.to_image(generated[:20])\n</pre> # dm.to_image(generated[:20])  Out[40]: In\u00a0[41]: Copied! <pre># dm.to_image(motif)\n</pre> # dm.to_image(motif)  Out[41]: In\u00a0[48]: Copied! <pre># # let's make some long sequence\n# generated = designer.motif_extension(motif=motif, n_samples_per_trial=N_SAMPLES, n_trials=1, sanitize=True, do_not_fragment_further=False, min_length=25, max_length=80)\n</pre> # # let's make some long sequence # generated = designer.motif_extension(motif=motif, n_samples_per_trial=N_SAMPLES, n_trials=1, sanitize=True, do_not_fragment_further=False, min_length=25, max_length=80)  <pre>2023-08-29 17:01:55.965 | INFO     | safe.sample:scaffold_decoration:534 - After sanitization, 98 / 100 (98.00 %)  generated molecules are valid !\n</pre> In\u00a0[49]: Copied! <pre># dm.to_image(generated[:20])\n</pre> # dm.to_image(generated[:20])  Out[49]: In\u00a0[44]: Copied! <pre># dm.to_image(side_chains)\n</pre> # dm.to_image(side_chains)  Out[44]: In\u00a0[45]: Copied! <pre># generated = designer.scaffold_morphing(side_chains=side_chains, n_samples_per_trial=N_SAMPLES, n_trials=1, sanitize=True, do_not_fragment_further=False, random_seed=100)\n# dm.to_image(generated[:20])\n</pre> # generated = designer.scaffold_morphing(side_chains=side_chains, n_samples_per_trial=N_SAMPLES, n_trials=1, sanitize=True, do_not_fragment_further=False, random_seed=100) # dm.to_image(generated[:20])  <pre>2023-08-29 17:00:14.942 | INFO     | safe.sample:_fragment_linking:389 - After sanitization, 100 / 100 (100.00 %)  generated molecules are valid !\n</pre> Out[45]: In\u00a0[46]: Copied! <pre># dm.to_image(linker_generation)\n</pre> # dm.to_image(linker_generation)  Out[46]: In\u00a0[47]: Copied! <pre># generated = designer.linker_generation(*linker_generation, n_samples_per_trial=N_SAMPLES, n_trials=1, sanitize=True, do_not_fragment_further=False, random_seed=100)\n# dm.to_image(generated[:20])\n</pre> # generated = designer.linker_generation(*linker_generation, n_samples_per_trial=N_SAMPLES, n_trials=1, sanitize=True, do_not_fragment_further=False, random_seed=100) # dm.to_image(generated[:20])  <pre>2023-08-29 17:00:27.044 | INFO     | safe.sample:_fragment_linking:389 - After sanitization, 100 / 100 (100.00 %)  generated molecules are valid !\n</pre> Out[47]:"},{"location":"tutorials/design-with-safe.html#de-novo-generation","title":"De novo generation\u00b6","text":"<p>Generation of novel molecules without any constraints.</p>"},{"location":"tutorials/design-with-safe.html#scaffold-decoration","title":"Scaffold Decoration\u00b6","text":"<p>For scaffold decoration, we wish to generate new molecules that would contain a given scaffold as core. Usually, the attachment point on the scaffold should dictate where the new vectors will be added.</p>"},{"location":"tutorials/design-with-safe.html#super-structure-generation","title":"Super structure generation\u00b6","text":"<p>In super structure generation, we just want to generate superstructure of a molecular subgraph</p>"},{"location":"tutorials/design-with-safe.html#motif-extension","title":"Motif Extension\u00b6","text":"<p>In motif extension, we are interested in generating a molecule containing a given motif as starting point.</p>"},{"location":"tutorials/design-with-safe.html#scaffold-morphing","title":"Scaffold Morphing\u00b6","text":"<p>In scaffold morphing, we wish to replace a scaffold by another one in a molecule. The process requires as input that the user provides either the side chains or the input molecules and the core</p>"},{"location":"tutorials/design-with-safe.html#linker-generation","title":"Linker generation\u00b6","text":"<p>Linker generation is mostly the same thing as scaffold morphing ...</p>"},{"location":"tutorials/getting-started.html","title":"Getting Started with SAFE","text":"In\u00a0[2]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n</pre> %load_ext autoreload %autoreload 2  <pre>The autoreload extension is already loaded. To reload it, use:\n  %reload_ext autoreload\n</pre> In\u00a0[3]: Copied! <pre>import safe as sf\nimport datamol as dm\n\ncelecoxib = \"Cc1ccc(-c2cc(C(F)(F)F)nn2-c2ccc(S(N)(=O)=O)cc2)cc1\"\ncelecoxib_mol = dm.to_mol(celecoxib)\ndisplay(dm.to_image(celecoxib_mol))\n</pre> import safe as sf import datamol as dm  celecoxib = \"Cc1ccc(-c2cc(C(F)(F)F)nn2-c2ccc(S(N)(=O)=O)cc2)cc1\" celecoxib_mol = dm.to_mol(celecoxib) display(dm.to_image(celecoxib_mol))  In\u00a0[11]: Copied! <pre>safe_str = sf.encode(celecoxib_mol)\nprint(safe_str)\nprint(f\"Representation using {len(safe_str.split('.'))} fragments\")\n</pre> safe_str = sf.encode(celecoxib_mol) print(safe_str) print(f\"Representation using {len(safe_str.split('.'))} fragments\")  <pre>c13ccc(S(N)(=O)=O)cc1.Cc1ccc4cc1.c14cc5nn13.C5(F)(F)F\nRepresentation using 4 fragments\n</pre> <p>SAFE string are SMILES</p> <p>Any SAFE string is a valid SMILES and can be read by RDKit without any decoding trick.</p> In\u00a0[12]: Copied! <pre>reconstructed = dm.to_mol(safe_str)\ndisplay(dm.to_image(reconstructed))\ndm.same_mol(celecoxib_mol, reconstructed)\n</pre> reconstructed = dm.to_mol(safe_str) display(dm.to_image(reconstructed)) dm.same_mol(celecoxib_mol, reconstructed)  Out[12]: <pre>True</pre> <p>SAFE supports randomization</p> <p>You can generate randomized SAFE strings.</p> In\u00a0[13]: Copied! <pre>random_safe_str = sf.encode(celecoxib_mol, canonical=False, randomize=True)\nprint(random_safe_str)\nreconstructed = dm.to_mol(safe_str)\ndm.same_mol(celecoxib_mol, reconstructed)\n</pre> random_safe_str = sf.encode(celecoxib_mol, canonical=False, randomize=True) print(random_safe_str) reconstructed = dm.to_mol(safe_str) dm.same_mol(celecoxib_mol, reconstructed)  <pre>C6(F)(F)F.c15ccc(C)cc1.c15cc6nn14.c14ccc(S(N)(=O)=O)cc1\n</pre> Out[13]: <pre>True</pre> <p>Fragment order in SAFE does not matter</p> <p>Any permutation of the fragment order in a SAFE string preserve the molecule identity</p> In\u00a0[14]: Copied! <pre>import numpy as np\n\nfragments = safe_str.split(\".\")\nrandomized_fragment_safe_str = np.random.permutation(fragments).tolist()\nrandomized_fragment_safe_str = \".\".join(randomized_fragment_safe_str)\n\nprint(randomized_fragment_safe_str, safe_str)\ndm.same_mol(celecoxib_mol, randomized_fragment_safe_str)\n</pre> import numpy as np  fragments = safe_str.split(\".\") randomized_fragment_safe_str = np.random.permutation(fragments).tolist() randomized_fragment_safe_str = \".\".join(randomized_fragment_safe_str)  print(randomized_fragment_safe_str, safe_str) dm.same_mol(celecoxib_mol, randomized_fragment_safe_str)  <pre>c13ccc(S(N)(=O)=O)cc1.C5(F)(F)F.Cc1ccc4cc1.c14cc5nn13 c13ccc(S(N)(=O)=O)cc1.Cc1ccc4cc1.c14cc5nn13.C5(F)(F)F\n</pre> Out[14]: <pre>True</pre> <p>Use your own slicing logic</p> <p>By default SAFE strings are generated using <code>BRICS</code>, however, the following are supported:</p> <ul> <li>Hussain-Rea (<code>hr</code>)</li> <li>RECAP (<code>recap</code>)</li> <li>RDKit's MMPA (<code>mmpa</code>)</li> <li>Any possible attachment points (<code>attach</code>)</li> </ul> <p>Furthermore, you can also provide your own slicing algorithm, which should return a pair of atoms corresponding to the bonds to break.</p> In\u00a0[16]: Copied! <pre># safe_str = sf.encode(celecoxib_mol, canonical=False, slicer=\"attach\")\n\n# print(safe_str)\n# print(f\"Representation using {len(safe_str.split('.'))} fragments\")\n# display(dm.to_image(safe_str))\n</pre> # safe_str = sf.encode(celecoxib_mol, canonical=False, slicer=\"attach\")  # print(safe_str) # print(f\"Representation using {len(safe_str.split('.'))} fragments\") # display(dm.to_image(safe_str))  In\u00a0[17]: Copied! <pre>def my_slicer(mol):\n    \"\"\"Slice on non single bonds where at both atoms are in a distinct rings\"\"\"\n    for bond in mol.GetBonds():\n        if bond.GetBondType() == dm.SINGLE_BOND and not bond.IsInRing() and (bond.GetBeginAtom().IsInRing() and bond.GetEndAtom().IsInRing()):\n            yield (bond.GetBeginAtomIdx(), bond.GetEndAtomIdx())\n</pre> def my_slicer(mol):     \"\"\"Slice on non single bonds where at both atoms are in a distinct rings\"\"\"     for bond in mol.GetBonds():         if bond.GetBondType() == dm.SINGLE_BOND and not bond.IsInRing() and (bond.GetBeginAtom().IsInRing() and bond.GetEndAtom().IsInRing()):             yield (bond.GetBeginAtomIdx(), bond.GetEndAtomIdx())  In\u00a0[19]: Copied! <pre># safe_str = sf.encode(celecoxib_mol, canonical=True, slicer=my_slicer)\n# print(safe_str)\n# print(f\"Representation using {len(safe_str.split('.'))} fragments\")\n</pre> # safe_str = sf.encode(celecoxib_mol, canonical=True, slicer=my_slicer) # print(safe_str) # print(f\"Representation using {len(safe_str.split('.'))} fragments\")  In\u00a0[20]: Copied! <pre># The above is equivalent to using the following SMARTS:\nsmart_slicer = [\"[r]-;!@[r]\"]\nsafe_str = sf.encode(celecoxib_mol, canonical=True, slicer=smart_slicer)\nprint(safe_str)\nprint(f\"Representation using {len(safe_str.split('.'))} fragments\")\n</pre> # The above is equivalent to using the following SMARTS: smart_slicer = [\"[r]-;!@[r]\"] safe_str = sf.encode(celecoxib_mol, canonical=True, slicer=smart_slicer) print(safe_str) print(f\"Representation using {len(safe_str.split('.'))} fragments\")  <pre>c13cc(C(F)(F)F)nn14.c14ccc(S(N)(=O)=O)cc1.Cc1ccc3cc1\nRepresentation using 3 fragments\n</pre> In\u00a0[11]: Copied! <pre>safe_fragment = safe_str.split(\".\")\nsafe_fragment\n</pre> safe_fragment = safe_str.split(\".\") safe_fragment  Out[11]: <pre>['c13cc(C(F)(F)F)nn14', 'c14ccc(S(N)(=O)=O)cc1', 'Cc1ccc3cc1']</pre> In\u00a0[12]: Copied! <pre># the following will fail\ndm.to_mol(safe_fragment[0])\n</pre> # the following will fail dm.to_mol(safe_fragment[0])  <pre>[14:10:13] SMILES Parse Error: unclosed ring for input: 'c13cc(C(F)(F)F)nn14'\n</pre> In\u00a0[13]: Copied! <pre># while this works\nsf.decode(safe_fragment[0], as_mol=True)\n</pre> # while this works sf.decode(safe_fragment[0], as_mol=True)  Out[13]: In\u00a0[14]: Copied! <pre># if you want to keep the attachment points, then use remove_dummies=False\nsf.decode(safe_fragment[0], as_mol=True, remove_dummies=False)\n</pre> # if you want to keep the attachment points, then use remove_dummies=False sf.decode(safe_fragment[0], as_mol=True, remove_dummies=False)  Out[14]: In\u00a0[15]: Copied! <pre>sf.to_image(safe_str)\n</pre> sf.to_image(safe_str)  Out[15]: <p>There are 3 display modes for highlighting the fragments in a SAFE string. The difference between those modes is highlighted below using two different slicing algorithm.</p> <p>!!! danger \"Overlapping fragments\" Note that because some fragment might be matching overlapping substructure of the molecules (for example the same fragment appearing multiple time in the molecule), the highlighting might assigned the same color to these fragments.</p> In\u00a0[16]: Copied! <pre>from IPython.display import display\nfrom ipywidgets import widgets, HBox\n\ndef display_image(safe_str):\n    image_lasso = widgets.Image(value=sf.to_image(safe_str, highlight_mode=\"lasso\", legend=\"lasso mode\").data.encode(), format='svg+xml')\n    image_fill = widgets.Image(value=sf.to_image(safe_str, highlight_mode=\"fill\", legend=\"fill mode\").data.encode(), format='svg+xml')\n    image_color = widgets.Image(value=sf.to_image(safe_str, highlight_mode=\"color\", legend=\"color mode\").data.encode(), format='svg+xml')\n    hbox = HBox([image_lasso, image_fill, image_color])\n    display(hbox)\n</pre>  from IPython.display import display from ipywidgets import widgets, HBox  def display_image(safe_str):     image_lasso = widgets.Image(value=sf.to_image(safe_str, highlight_mode=\"lasso\", legend=\"lasso mode\").data.encode(), format='svg+xml')     image_fill = widgets.Image(value=sf.to_image(safe_str, highlight_mode=\"fill\", legend=\"fill mode\").data.encode(), format='svg+xml')     image_color = widgets.Image(value=sf.to_image(safe_str, highlight_mode=\"color\", legend=\"color mode\").data.encode(), format='svg+xml')     hbox = HBox([image_lasso, image_fill, image_color])     display(hbox)  In\u00a0[17]: Copied! <pre># display for brics\nsafe_str_brics = sf.encode(celecoxib_mol, canonical=True, slicer=\"brics\")\ndisplay_image(safe_str_brics)\n</pre> # display for brics safe_str_brics = sf.encode(celecoxib_mol, canonical=True, slicer=\"brics\") display_image(safe_str_brics)  <pre>HBox(children=(Image(value=b'&lt;svg xmlns=\"http://www.w3.org/2000/svg\" ...', format='svg+xml'), Image(value=b'&lt;s\u2026</pre> In\u00a0[18]: Copied! <pre># display with HR\nsafe_str_hr = sf.encode(celecoxib_mol, canonical=True, slicer=\"mmpa\")\ndisplay_image(safe_str_hr)\n</pre> # display with HR safe_str_hr = sf.encode(celecoxib_mol, canonical=True, slicer=\"mmpa\") display_image(safe_str_hr)  <pre>HBox(children=(Image(value=b'&lt;svg xmlns=\"http://www.w3.org/2000/svg\" ...', format='svg+xml'), Image(value=b'&lt;s\u2026</pre> In\u00a0[19]: Copied! <pre>import datamol as dm\nimport safe as sf\nfrom rdkit import Chem\nfrom rdkit.Chem.Draw import rdDepictor\nfrom rdkit.Chem import rdChemReactions as rdr\nrdDepictor.SetPreferCoordGen(True)\n</pre> import datamol as dm import safe as sf from rdkit import Chem from rdkit.Chem.Draw import rdDepictor from rdkit.Chem import rdChemReactions as rdr rdDepictor.SetPreferCoordGen(True)  In\u00a0[20]: Copied! <pre>smiles = ['c1ccccc1', 'OC', 'c1cc(*)ccc1', 'O(*)C', 'c1cc(*)ccc1.O(*)C']\nlegends = ['benzene', 'methanol', 'phenyl group', 'Methoxy group', 'composite']\ndm.viz.to_image([dm.to_mol(x) for x in smiles], legends=legends, n_cols=len(smiles), use_svg=True)\n</pre> smiles = ['c1ccccc1', 'OC', 'c1cc(*)ccc1', 'O(*)C', 'c1cc(*)ccc1.O(*)C'] legends = ['benzene', 'methanol', 'phenyl group', 'Methoxy group', 'composite'] dm.viz.to_image([dm.to_mol(x) for x in smiles], legends=legends, n_cols=len(smiles), use_svg=True)  Out[20]: <p>In the example above, we can see that <code>phenol</code> can be represented as two fragments that can be connected given proper attachment point.</p> <p>To achieve this we are interested in attaching 2 fragments together (the <code>methoxy</code> and the <code>phenyl</code> groups). In RDKit, this can usually be achieved using chemical reactions. For convenience, we will prefer a standardized representation of attachment points that includes an atom mapping.</p> In\u00a0[21]: Copied! <pre>smiles = [ 'c1cc(*)ccc1.O(*)C', 'c1cc([*:1])ccc1.O([*:1])C'] #\ndm.viz.to_image([dm.to_mol(x) for x in smiles], n_cols=len(smiles), use_svg=True)\n</pre> smiles = [ 'c1cc(*)ccc1.O(*)C', 'c1cc([*:1])ccc1.O([*:1])C'] # dm.viz.to_image([dm.to_mol(x) for x in smiles], n_cols=len(smiles), use_svg=True)  Out[21]: <p>To attach the two fragments, I can write a simple chemical transformation. Since smarts and smiles syntax do not mix very well when it comes to <code>*</code> I will assume an isotopic representation <code>[1*]</code> instead of <code>[*:1]</code></p> In\u00a0[22]: Copied! <pre>rxn = rdr.ReactionFromSmarts(\"[1*][*:1].[1*][*:2]&gt;&gt;[*:1][*:2]\")\nrxn\n</pre> rxn = rdr.ReactionFromSmarts(\"[1*][*:1].[1*][*:2]&gt;&gt;[*:1][*:2]\") rxn  Out[22]: In\u00a0[23]: Copied! <pre># replace atom map by isotopes\nphenyl = \"c1cc([*:1])ccc1\".replace(\"[*:1]\", \"[1*]\")\nmethoxy = \"O([*:1])C\".replace(\"[*:1]\", \"[1*]\")\n\n# runreactions\nprod = rxn.RunReactants((dm.to_mol(phenyl), dm.to_mol(methoxy)))\nprod[0][0]\n</pre> # replace atom map by isotopes phenyl = \"c1cc([*:1])ccc1\".replace(\"[*:1]\", \"[1*]\") methoxy = \"O([*:1])C\".replace(\"[*:1]\", \"[1*]\")  # runreactions prod = rxn.RunReactants((dm.to_mol(phenyl), dm.to_mol(methoxy))) prod[0][0]  Out[23]: <p>We can achieve the same result by using rdkit API in an slightly more tedious way.</p> In\u00a0[24]: Copied! <pre>replacement_sub =  Chem.MolFromSmarts(\"[1*]\")\nprod = Chem.ReplaceSubstructs(dm.to_mol(phenyl), replacement_sub, dm.to_mol(methoxy), replacementConnectionPoint=0)\nprod = dm.remove_dummies(prod[0], dummy=\"[1*]\")\nprod\n</pre> replacement_sub =  Chem.MolFromSmarts(\"[1*]\") prod = Chem.ReplaceSubstructs(dm.to_mol(phenyl), replacement_sub, dm.to_mol(methoxy), replacementConnectionPoint=0) prod = dm.remove_dummies(prod[0], dummy=\"[1*]\") prod  <pre>[14:10:33] WARNING: not removing hydrogen atom without neighbors\n</pre> Out[24]: <p>But wait, could we attach the fragment using only the string operations on the smiles ?</p> <p>Well, it's not possible by trying to perform substring replacement, but recall we just said that <code>numbers in smiles represents connectivity points</code> ?</p> In\u00a0[25]: Copied! <pre>phenyl = \"c1cc([*:1])ccc1\"\nmethoxy = \"O([*:1])C\"\ncomposite = phenyl + \".\" + methoxy # c1cc([*:1])ccc1.O([*:1])C\ncompo = dm.to_mol(composite)\n</pre> phenyl = \"c1cc([*:1])ccc1\" methoxy = \"O([*:1])C\" composite = phenyl + \".\" + methoxy # c1cc([*:1])ccc1.O([*:1])C compo = dm.to_mol(composite)  <p>Since <code>1</code> \"connectivity point\" is already present in the phenyl group. We need to start by opening a new connectivity point: <code>2</code></p> In\u00a0[26]: Copied! <pre>attached_composite = composite.replace(\"[*:1]\", \"2\")\ndm.to_mol(attached_composite)\n</pre> attached_composite = composite.replace(\"[*:1]\", \"2\") dm.to_mol(attached_composite)  <pre>[14:10:35] SMILES Parse Error: syntax error while parsing: c1cc(2)ccc1.O(2)C\n[14:10:35] SMILES Parse Error: Failed parsing SMILES 'c1cc(2)ccc1.O(2)C' for input: 'c1cc(2)ccc1.O(2)C'\n</pre> <p>The previous line does not work because of violation in the smiles syntax. As we are not taking into account the branching bracket surrounding the attachment point.</p> <p>We could try to regenerate the smiles or scan the sequence and remove the brackets when it's possible, but we want to limit the operations to <code>str.replace</code>. So let's try again.</p> In\u00a0[27]: Copied! <pre>attached_composite = composite.replace(\"([*:1])\", \"2\").replace(\"[*:1]\", \"2\")\ndm.to_image(attached_composite, legends=[attached_composite])\n</pre> attached_composite = composite.replace(\"([*:1])\", \"2\").replace(\"[*:1]\", \"2\") dm.to_image(attached_composite, legends=[attached_composite])  Out[27]: <p>You can see that the phenol molecule is represented as two \"fragments\" <code>[Fragment1].[Fragment2]</code>. That is what SAFE is about.</p> <p>In summary, to build a SAFE string, we just need to follow the step below:</p> <p></p>"},{"location":"tutorials/getting-started.html#getting-started-with-safe","title":"Getting Started with SAFE\u00b6","text":"<p>The SAFE encoding format is a rewriting of SMILES to ensure that any molecule can be written as a sequence of fragments where atoms or tokens corresponding to given fragments form a substring(ontiguous sequence) in the line notation representation.</p> <p>SAFE addresses some of the limitation of SMILES strings when it comes to generative design:</p> SAFE Others <sub> <pre>+ native support for (sub)structure-constrained design\n</pre> </sub> <sub> <pre>- different generative models for different generative tasks \n- extensive substructure matching for filtering after generation\n- multiple steps generative process (e.g Liao et al. 2023, 10.1093/bioinformatics/btac814)\n- graph based approaches with their limitations\n</pre> </sub> <sub> <pre>+ any molecule generation as a simple NLP task (sequence completion or mask filling)\n+ a single autoregressive sequence model for both linker generation and scaffold decoration.\n</pre> </sub> <sub> <pre>- complex training and decoding schemes for scaffold-constrained generation (e.g Ar\u00fas-Pous et al. 2020, 10.1186/s13321-020-00441-8)\n- complex sampling algorithms for scaffold-constrained generation (e.g Langevin et al. 2020, 10.1021/acs.jcim.0c01015)\n</pre> </sub> <sub> <pre>+ SAFE strings are SMILES strings\n</pre> </sub> <sub> <pre>- requires a different chemical language (e.g Krenn et al. 2022, 10.1016/j.patter.2022.100588)\n</pre> </sub>"},{"location":"tutorials/getting-started.html#using-safe","title":"Using SAFE\u00b6","text":"<p>In the following we will highlight how to use SAFE and some of the properties of SAFE strings.</p>"},{"location":"tutorials/getting-started.html#encoding","title":"Encoding\u00b6","text":"<p>SAFE represents fragments</p> <p>SAFE represents molecules as a set of N [Fragment_1].[Fragment_i].[Fragment_N]</p>"},{"location":"tutorials/getting-started.html#decoding","title":"Decoding\u00b6","text":"<p>!!! info \"Fragment order in SAFE does not matter\"</p> <pre><code>Each `SAFE fragment` is a valid molecule itself, however, you need to use the decoder to recover molecules where all attachment point are not fullfiled.</code></pre>"},{"location":"tutorials/getting-started.html#displaying-a-safe-encoding","title":"Displaying a SAFE encoding\u00b6","text":"<p>We provide a visualization module to display a safe string, with highlight of all the fragments that compose it.</p>"},{"location":"tutorials/getting-started.html#understanding-safe","title":"Understanding SAFE\u00b6","text":"<p>The intuition behind safe is quite simple: we want to represent any molecule as a  <code>set of connected fragments</code>.</p>"},{"location":"tutorials/getting-started.html#preliminary-on-smiles","title":"Preliminary on SMILES.\u00b6","text":"<p>Let's start first by revisiting some information about the SMILES syntax:</p> <ul> <li><p>An asterisk <code>*</code> in a smiles is usually employed to indicate any atom OR an attachment point of any group. It's particularly useful for smarts matching.</p> </li> <li><p>Number in smiles syntax indicates connectivity points between two atoms. For 2 digits numbers they would need to be preceeded by <code>%</code>.</p> </li> </ul> <p>This is partially explained on the wikipedia ring section of SMILES.</p> <ul> <li>A dot <code>.</code> in smiles indicates the presence of additional fragments and is used to separate them.</li> </ul> <p>A good ressource on the subject is the DAYLIGHT page.</p> <p>We illustrate these informations below !</p>"}]}